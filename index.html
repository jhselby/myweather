<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- iOS Web App Config -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Wyman Cove" />

  <title>Wyman Cove Weather</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>

  <style>
    :root{
      --bg: #0b1220;
      --card: rgba(255, 255, 255, 0.06);
      --card2: rgba(255, 255, 255, 0.09);
      --border: rgba(255, 255, 255, 0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);
      --muted2: rgba(255,255,255,0.55);
      --accent: rgba(255,255,255,0.18);
      --shadow: 0 10px 28px rgba(0,0,0,0.35);
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, rgba(84, 150, 255, 0.25), transparent 55%),
                  radial-gradient(900px 500px at 80% 0%, rgba(90, 255, 190, 0.12), transparent 55%),
                  var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 980px;
      margin: 0 auto;
      padding: 16px 14px 28px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 14px 14px 12px;
      border: 1px solid var(--border);
      border-radius: 18px;
      background: rgba(255,255,255,0.05);
      box-shadow: var(--shadow);
      position: sticky;
      top: 10px;
      z-index: 50;
      backdrop-filter: blur(10px);
    }

    header h1 {
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: 0.2px;
      font-weight: 900;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .version-pill{
      font-size: 0.78rem;
      font-weight: 800;
      color: rgba(255,255,255,0.78);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      white-space: nowrap;
    }

    .meta-row{
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
      color: var(--muted);
      font-size: 0.92rem;
    }

    .meta-item{
      display: inline-flex;
      gap: 8px;
      align-items: center;
      white-space: nowrap;
    }

    .meta-label{
      color: rgba(255,255,255,0.55);
      font-weight: 800;
      letter-spacing: 0.2px;
    }

    .meta-value{
      color: rgba(255,255,255,0.86);
      font-weight: 800;
    }

    .source-row{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    .source-pill{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      font-size: 0.82rem;
      font-weight: 800;
      color: rgba(255,255,255,0.86);
    }
    .source-pill .small{
      font-weight: 800;
      color: rgba(255,255,255,0.65);
    }

    .tabs{
      margin-top: 6px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .tab{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      transition: transform 0.06s ease, background 0.15s ease;
      -webkit-tap-highlight-color: transparent;
    }
    .tab:active{ transform: scale(0.98); }
    .tab.active{
      background: rgba(255,255,255,0.18);
      border-color: rgba(255,255,255,0.28);
    }

    .grid {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }

    .card{
      grid-column: span 6;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px 14px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .card.col-12{ grid-column: span 12; }
    .card.col-6{ grid-column: span 6; }

    .card-title-collapsible{
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .card-title-collapsible:hover{ color: rgba(255,255,255,1); }
    .collapse-chevron{
      font-size: 0.75rem;
      color: rgba(255,255,255,0.4);
      font-weight: 700;
      margin-left: 8px;
      transition: transform 0.2s;
    }
    .card-title{
      font-weight: 900;
      color: rgba(255,255,255,0.88);
      font-size: 0.95rem;
      letter-spacing: 0.2px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
    }

    .small-note{
      color: rgba(255,255,255,0.6);
      font-size: 0.85rem;
      line-height: 1.2rem;
      margin-top: 8px;
    }

    .current-temp{
      position: relative;
      font-size: 3rem;
      font-weight: 1000;
      letter-spacing: -1px;
      margin-top: 8px;
    }

    .temp-unit{
      font-size: 1.25rem;
      font-weight: 900;
      color: rgba(255,255,255,0.7);
      margin-left: 6px;
    }

    .feels-like{
      position: relative;
      margin-top: 2px;
      font-size: 1rem;
      color: rgba(255,255,255,0.76);
      font-weight: 800;
    }

    .condition{
      position: relative;
      margin-top: 10px;
      font-size: 1.05rem;
      font-weight: 900;
      color: rgba(255,255,255,0.86);
    }

    .row{
      display: flex;
      justify-content: space-between;
      gap: 10px;
      padding: 7px 0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 0.95rem;
    }
    .row:last-child{ border-bottom: none; }

    .label{
      color: rgba(255,255,255,0.62);
      font-weight: 800;
    }
    /* Wind window pill buttons */
    .wind-window-pills { display:flex; gap:4px; }
    .wpill {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      color: rgba(255,255,255,0.5);
      border-radius: 999px;
      padding: 3px 10px;
      font-size: 0.75rem;
      font-weight: 800;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    .wpill:hover { background: rgba(255,255,255,0.14); color: rgba(255,255,255,0.8); }
    .wpill.active { background: rgba(100,160,255,0.25); border-color: rgba(100,160,255,0.5); color: rgba(160,200,255,0.95); }
    /* Pure-CSS hover tooltips ‚Äî add data-tip="..." to any element */
    [data-tip]{
      position: relative;
      cursor: default;
      text-decoration: underline dotted rgba(255,255,255,0.3);
    }
    [data-tip]::after{
      content: attr(data-tip);
      position: absolute;
      bottom: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20,24,36,0.97);
      color: rgba(255,255,255,0.88);
      font-size: 0.72rem;
      font-weight: 600;
      line-height: 1.4;
      padding: 6px 10px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.12);
      white-space: normal;
      width: max-content;
      max-width: 220px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      z-index: 9999;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    }
    [data-tip]:hover::after{ opacity: 1; }
    [data-tip].tip-active::after{ opacity: 1; }
    .value{
      color: rgba(255,255,255,0.9);
      font-weight: 900;
      text-align: right;
      white-space: nowrap;
    }

    .pressure-alarm{
      border-radius: 14px;
      padding: 10px 16px;
      margin: 8px 0 4px 0;
      font-weight: 800;
      font-size: 0.92rem;
      text-align: center;
      display: none;
    }
    .pressure-alarm.falling{
      background: rgba(255,80,80,0.18);
      border: 1px solid rgba(255,80,80,0.4);
      color: rgba(255,180,180,0.95);
    }
    .pressure-alarm.rising{
      background: rgba(80,200,120,0.15);
      border: 1px solid rgba(80,200,120,0.35);
      color: rgba(150,240,180,0.95);
    }
    .alert-banner{
      background: rgba(255, 80, 80, 0.18);
      border: 1px solid rgba(255, 80, 80, 0.30);
      border-radius: 16px;
      padding: 12px 14px;
      margin-top: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    }
    .alert-title{ font-weight: 1000; }
    .alert-desc{ color: rgba(255,255,255,0.78); margin-top: 4px; }

    .tide-grid{
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 8px;
    }
    .tide-item{
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.05);
    }
    .tide-item .tide-type{
      font-weight: 1000;
      color: rgba(255,255,255,0.85);
      margin-bottom: 2px;
    }
    .tide-item .tide-time{
      font-weight: 900;
      color: rgba(255,255,255,0.78);
    }
    .tide-item .tide-height{
      font-weight: 900;
      color: rgba(255,255,255,0.72);
      font-size: 0.9rem;
    }

    canvas{
      width: 100% !important;
      height: 220px !important;
    }

    @media (max-width: 780px){
      .card{ grid-column: span 12; }
      canvas{ height: 240px !important; }
      header{ position: relative; top: 0; }
    }
    /* --- iOS Chart Fix --- */
    canvas {
    display: block;  
    }

    #windChart {
    width: 100% !important;
    height: 220px !important;
    }

    /* Make 48-hour charts less ‚Äústretched‚Äù on wide screens */
  @media (min-width: 900px) {
  #tempPrecipChart, #windChart {
    height: 420px !important;
  }
}

/* Also helps iPhone landscape / tablet landscape */
@media (orientation: landscape) and (max-width: 900px) {
  #tempPrecipChart, #windChart {
    height: 260px !important;
  }
}
  /* --- Wind Risk tiles --- */
.risk-tiles{
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
  margin: 12px 0 14px 0;
}

@media (max-width: 780px){
  .risk-tiles{
    grid-template-columns: repeat(2, 1fr);
  }
}

.risk-tile{
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.04);
  border-radius: 16px;
  padding: 12px 12px 10px 12px;
}

.risk-tile .kicker{
  font-weight: 700;
  opacity: 0.85;
  margin-bottom: 6px;
}

.risk-tile .big{
  font-size: 22px;
  font-weight: 800;
  line-height: 1.05;
  margin-bottom: 4px;
}

.risk-tile .sub{
  font-size: 13px;
  opacity: 0.7;
}

/* Risk badge colors */
.badge{
  display: inline-block;
  padding: 3px 9px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  margin-left: 6px;
  border: 1px solid rgba(255,255,255,0.15);
}

.badge.calm         { background: rgba(160,160,160,0.18); }
.badge.breezy       { background: rgba(100,180,255,0.22); }
.badge.notable      { background: rgba(255,170,0,0.22); }
.badge.significant  { background: rgba(255,80,80,0.25); }
.badge.severe       { background: rgba(200,60,255,0.30); }
  
    /* Radar tab */
    .radar-btn {
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.15);
      color: rgba(255,255,255,0.6);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.78rem;
      font-weight: 900;
      cursor: pointer;
      transition: all 0.15s;
    }
    .radar-btn:hover { background: rgba(255,255,255,0.12); color: rgba(255,255,255,0.9); }
    .radar-btn-active {
      background: rgba(100,180,255,0.18) !important;
      border-color: rgba(100,180,255,0.5) !important;
      color: rgba(140,210,255,0.95) !important;
    }
    /* Override Leaflet defaults for dark theme */
    .leaflet-container { background: #0b1220 !important; }
    .leaflet-control-attribution {
      background: rgba(0,0,0,0.6) !important;
      color: rgba(255,255,255,0.4) !important;
      font-size: 10px !important;
    }
    .leaflet-control-attribution a { color: rgba(255,255,255,0.5) !important; }
    .leaflet-control-zoom a {
      background: rgba(20,30,50,0.9) !important;
      color: rgba(255,255,255,0.8) !important;
      border-color: rgba(255,255,255,0.15) !important;
    }
</style>
</head>

<body>
  <div class="container">
    <header>
      <h1>
        ‚öì Wyman Cove Weather
        <span class="version-pill" id="appVersion">v2.0</span>
      </h1>

      <div class="meta-row">
        <div class="meta-item">
          <span class="meta-label">Location</span>
          <span class="meta-value" id="location">Loading‚Ä¶</span>
        </div>

        <div class="meta-item">
          <span class="meta-label">Data generated</span>
          <span class="meta-value" id="dataUpdated">--</span>
        </div>

        <div class="meta-item">
          <span class="meta-label">Page loaded</span>
          <span class="meta-value" id="pageLoaded">--</span>
        </div>
      </div>

      <nav class="tabs" role="tablist" aria-label="Views">
        <button class="tab active" id="tabWeather" role="tab" aria-selected="true" onclick="showTab('weather')">Weather</button>
        <button class="tab" id="tabWind" role="tab" aria-selected="false" onclick="showTab('wind')">Wind</button>
        <button class="tab" id="tabAlmanac" role="tab" aria-selected="false" onclick="showTab('almanac')">Almanac</button>
        <button class="tab" id="tabRadar"   role="tab" aria-selected="false" onclick="showTab('radar')">Radar</button>
        <button class="tab" id="tabSources" role="tab" aria-selected="false" onclick="showTab('sources')" style="border-color:rgba(100,220,100,0.3);">Sources</button>
      </nav>

      <!-- Banners ‚Äî sticky with header, below tabs -->
      <div id="pressureAlarmBanner" class="pressure-alarm" style="margin:0;border-radius:10px;"></div>
      <div id="stormModeBanner" style="display:none;border-radius:10px;padding:10px 14px;
        margin:4px 0 0 0;background:rgba(255,60,60,0.18);border:1px solid rgba(255,60,60,0.45);
        color:rgba(255,200,200,0.95);">
        <div style="font-weight:900;font-size:0.92rem;cursor:pointer;user-select:none;display:flex;align-items:center;justify-content:space-between;"
             onclick="const d=document.getElementById('stormModeDetails');const c=document.getElementById('stormModeChev');const open=d.style.display!=='none';d.style.display=open?'none':'';c.innerHTML=open?'&#9660; Show':'&#9650; Hide';">
          ‚õàÔ∏è Storm conditions developing
          <span id="stormModeChev" style="font-size:0.8rem;color:rgba(255,255,255,0.5);margin-left:8px;white-space:nowrap;">&#9660; Show</span>
        </div>
        <div id="stormModeDetails" style="display:none;font-size:0.85rem;color:rgba(255,180,180,0.85);line-height:1.6;margin-top:6px;"></div>
      </div>
      <!-- Consolidated alert summary bar -->
      <div id="alertSummaryBar" style="display:none;margin-top:6px;border-radius:10px;padding:8px 14px;
        background:rgba(255,80,80,0.18);border:1px solid rgba(255,80,80,0.35);cursor:pointer;
        display:none;align-items:center;justify-content:space-between;"
        onclick="toggleAlertPanel()">
        <span id="alertSummaryText" style="font-weight:900;font-size:0.88rem;color:rgba(255,200,200,0.95);"></span>
        <span id="alertSummaryChev" style="font-size:0.8rem;color:rgba(255,255,255,0.5);margin-left:8px;white-space:nowrap;">&#9660; Show</span>
      </div>
      <!-- Expandable alert detail panel -->
      <div id="alertsContainer" style="display:none;max-height:220px;overflow-y:auto;margin-top:4px;"></div>

    </header>



    <!-- WEATHER VIEW -->
    <section id="weatherView">
      <div class="grid">

        <!-- 1. Current Conditions ‚Äî open by default -->
        <div class="card col-12" data-collapse-key="current_conditions">
          <div class="card-title card-title-collapsible" onclick="toggleCard('current_conditions', this)">Current Conditions <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
          <div id="currentTemp" class="current-temp" data-tip="PWS-corrected temperature: raw model temp adjusted by your local weather station bias.">--<span class="temp-unit">&deg;F</span></div>
          <div id="feelsLike" class="feels-like" data-tip="Apparent temperature from GFS model, accounting for wind chill or heat index.">Feels like --&deg;F</div>
          <div id="condition" class="condition" data-tip="Sky/weather condition from GFS model weather code.">Loading&hellip;</div>
          </div>
        </div>

        <!-- 2. Today's Summary ‚Äî open by default -->
        <div class="card col-12" data-collapse-key="todays_summary">
          <div class="card-title card-title-collapsible" onclick="toggleCard('todays_summary', this)">Today&#39;s Summary <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
          <div class="row">
            <div class="label" data-tip="Forecast high and low temperatures for today from the ECMWF daily model.">High / Low</div>
            <div class="value" id="hiLo">-- / --</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Maximum precipitation probability for today from the ECMWF daily model.">Precip Chance</div>
            <div class="value" id="precipChance">--%</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Current wind speed and direction from the GFS model current conditions snapshot.">Wind (now)</div>
            <div class="value" id="windNowHome">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Mean sea level pressure from the GFS model. Useful for trend comparison with observed.">Pressure (model)</div>
            <div class="value" id="pressureModel">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Observed mean sea level pressure from KBOS (Boston Logan). More accurate than model ‚Äî use this for storm tracking.">Pressure (KBOS obs)</div>
            <div class="value" id="pressureKBOS">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Change in barometric pressure over the last 3 hours. Falling rapidly (>2 mb) suggests an approaching storm. Rising rapidly indicates clearing.">Pressure Trend (3h)</div>
            <div class="value" id="pressureTrendHome">--</div>
          </div>
          <div class="small-note" id="todayNote"></div>
          </div>
        </div>

        <!-- 3. Hyperlocal Comparison ‚Äî closed by default -->
        <div class="card col-12" data-collapse-key="hyperlocal" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('hyperlocal', this)">&#127968; Hyperlocal Comparison <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <div class="row">
            <div class="label" data-tip="Raw GFS model temperature at your location before any local correction.">Model Temp</div>
            <div class="value" id="modelTemp">--&deg;F</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Current temperature from your personal weather station ‚Äî your most accurate local reading.">PWS Temp</div>
            <div class="value" id="pwsTemp">--&deg;F</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Difference between model forecast and observed PWS temp. Used to correct the model output.">Bias</div>
            <div class="value" id="tempBias">--&deg;F</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Model temp adjusted by the observed PWS bias ‚Äî best estimate of actual conditions.">Corrected</div>
            <div class="value" id="correctedTemp">--&deg;F</div>
          </div>
          <div class="small-note" id="pwsNote"></div>
          </div>
        </div>

        <!-- 4. Conditions & Diagnostics ‚Äî closed by default -->
        <div class="card col-12" data-collapse-key="pressure_diag" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('pressure_diag', this)">Conditions &amp; Diagnostics <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <div class="row">
            <div class="label" data-tip="Observed temperatures at Boston Logan (KBOS, 15mi SW) and Beverly Airport (KBVY, 7mi NW). Useful reference points for regional gradient.">Temp: KBOS / KBVY</div>
            <div class="value" id="tempObsStations">-- / --</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Height of the 850mb pressure level (~5,000 ft). Rising height = warming aloft. Used to assess rain/snow/mix boundary.">850mb Height (6h)</div>
            <div class="value" id="troughSignal">--</div>
          </div>
          <div class="row" id="seaBreezeRow">
            <div class="label" data-tip="Likelihood of a sea breeze developing today. Sea breezes form when land heats faster than the ocean, drawing cool marine air onshore from the E/SE.">Sea Breeze</div>
            <div class="value" id="seaBreezeLabel">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Estimated fog probability based on temperature/dewpoint spread, wind speed, and humidity. High risk when spread is <2¬∞F and winds are calm.">Fog Risk (12h)</div>
            <div class="value" id="fogRisk">--</div>
          </div>
          <div class="row" id="precipTypeRow" style="display:none;">
            <div class="label" data-tip="Predicted precipitation type at ground level based on surface temperature. May differ from what falls aloft if there are warm/cold layers above.">Precip Type (surface)</div>
            <div class="value" id="precipType">--</div>
          </div>
          <div class="row" id="col850Row" style="display:none;">
            <div class="label" data-tip="Precipitation type suggested by the temperature at 850mb (~5,000 ft). A warm layer aloft with a cold surface can produce freezing rain or sleet.">Column type (850mb)</div>
            <div class="value" id="col850Type">--</div>
          </div>
          </div>
        </div>

        <!-- 5. 10-Day Forecast ‚Äî closed by default -->
        <div class="card col-12" data-collapse-key="ten_day" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('ten_day', this)">10-Day Forecast <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <div id="forecastList"></div>
          </div>
        </div>

        <!-- 6. 48-Hour Temp & Precip ‚Äî closed by default -->
        <div class="card col-12" data-collapse-key="48h_temp_precip" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('48h_temp_precip', this)">48-Hour Temperature &amp; Precipitation <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <canvas id="tempPrecipChart"></canvas>
          <div style="display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;font-size:0.75rem;font-weight:800;color:rgba(255,255,255,0.6);">
            <span><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:rgba(230,240,255,0.90);margin-right:4px;vertical-align:middle;"></span>Snow</span>
            <span><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:rgba(200,215,255,0.80);margin-right:4px;vertical-align:middle;"></span>Snow likely</span>
            <span><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:rgba(160,100,220,0.80);margin-right:4px;vertical-align:middle;"></span>Mixed/slush</span>
            <span><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:rgba(255,140,40,0.80);margin-right:4px;vertical-align:middle;"></span>Freezing rain</span>
            <span><span style="display:inline-block;width:12px;height:12px;border-radius:3px;background:rgba(60,130,255,0.70);margin-right:4px;vertical-align:middle;"></span>Rain</span>
          </div>
          </div>
        </div>

        <!-- 7. NWS Detailed Forecast ‚Äî closed by default -->
        <div class="card col-12" data-collapse-key="nws_forecast" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('nws_forecast', this)">&#128204; NWS Detailed Forecast
            <span style="font-size:0.78rem;font-weight:700;color:rgba(255,255,255,0.45);margin-left:8px;" id="nwsOfficeLabel"></span> <span class="collapse-chevron">&#9660;</span>
          </div>
          <div class="card-body" style="display:none;">
          <div id="nwsForecastList"></div>
          <div style="margin-top:10px;">
            <button id="nwsExpandBtn" onclick="nwsToggleExpand()"
              style="background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.15);
                     color:rgba(255,255,255,0.7);border-radius:999px;padding:6px 16px;
                     font-size:0.82rem;font-weight:800;cursor:pointer;display:none;">
              Show all periods
            </button>
          </div>
          <div class="small-note" style="margin-top:8px;">Written by NWS Boston meteorologists.</div>
        </div>

      </div>
    </section>
    <!-- WIND VIEW -->
    <section id="windView" style="display:none;">
      <div class="grid">

        <!-- Wind & Pressure (now) ‚Äî open by default -->
        <div class="card col-12" data-collapse-key="wind_now">
          <div class="card-title card-title-collapsible" onclick="toggleCard('wind_now', this)">Wind &amp; Pressure (now) <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
          <div class="row">
            <div class="label" data-tip="Current wind speed and direction from the GFS model snapshot.">Wind</div>
            <div class="value" id="windNowWind">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Current gust speed from the GFS model snapshot.">Gusts</div>
            <div class="value" id="windGustsWind">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Current mean sea level pressure from the GFS model.">Pressure</div>
            <div class="value" id="pressureNowWind">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Change in pressure over the last 2 hours. Prefers KBOS observed tendency when available (shown as [obs]), falls back to GFS model ([model]).">Trend (2h)</div>
            <div class="value" id="pressureTrendWind">--</div>
          </div>
          <div class="small-note" id="windPressureNote"></div>
          </div>
        </div>

        <!-- Gust Wind Impact ‚Äî collapsed by default, own window buttons -->
        <div class="card col-12" data-collapse-key="wind_gust_impact" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('wind_gust_impact', this)"
               style="display:flex;align-items:center;justify-content:space-between;">
            <span>&#127788; Gust Wind Impact <span class="collapse-chevron">&#9660;</span></span>
            <span class="wind-window-pills" id="gustWindowPills" onclick="event.stopPropagation()">
              <button class="wpill active" data-target="gust" data-hours="12">12h</button>
              <button class="wpill" data-target="gust" data-hours="24">24h</button>
              <button class="wpill" data-target="gust" data-hours="36">36h</button>
              <button class="wpill" data-target="gust" data-hours="48">48h</button>
            </span>
          </div>
          <div class="card-body" style="display:none;">
          <div class="row">
            <div class="label" data-tip="Plain-language severity: Calm / Breezy / Notable / Significant / Severe.">Level</div>
            <div class="value" id="gustLevel">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Exposure-weighted wind speed: raw mph √ó exposure factor^1.5. A 40 mph NW gust (full exposure) scores 40. Thresholds: Breezy ‚â•5, Notable ‚â•12, Significant ‚â•20, Severe ‚â•30.">Impact Score</div>
            <div class="value" id="gustScore">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Highest forecast gust speed within the selected time window.">Peak Gust</div>
            <div class="value" id="gustPeak">-- mph</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Wind direction at the time of peak gust.">Direction</div>
            <div class="value" id="gustDir">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="0‚Äì1 multiplier for your property's directional exposure. N/NW = 1.0 (full open water fetch from ocean). S/SE ‚âà 0.1 (sheltered by shoreline and property). Applied as exposure^1.5 so high-exposure directions are disproportionately penalized.">Exposure Factor</div>
            <div class="value" id="gustExposure">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Forecast time when peak gust is expected.">Peak Time</div>
            <div class="value" id="gustTime">--</div>
          </div>
          <div class="small-note" id="gustNote"></div>
          </div>
        </div>

        <!-- Sustained Wind Impact ‚Äî collapsed by default, own window buttons -->
        <div class="card col-12" data-collapse-key="wind_sus_impact" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('wind_sus_impact', this)"
               style="display:flex;align-items:center;justify-content:space-between;">
            <span>&#127787; Sustained Wind Impact <span class="collapse-chevron">&#9660;</span></span>
            <span class="wind-window-pills" id="susWindowPills" onclick="event.stopPropagation()">
              <button class="wpill active" data-target="sus" data-hours="12">12h</button>
              <button class="wpill" data-target="sus" data-hours="24">24h</button>
              <button class="wpill" data-target="sus" data-hours="36">36h</button>
              <button class="wpill" data-target="sus" data-hours="48">48h</button>
            </span>
          </div>
          <div class="card-body" style="display:none;">
          <div class="row">
            <div class="label" data-tip="Plain-language severity: Calm / Breezy / Notable / Significant / Severe.">Level</div>
            <div class="value" id="susLevel">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Exposure-weighted wind speed: raw mph √ó exposure factor^1.5. A 40 mph NW gust (full exposure) scores 40. Thresholds: Breezy ‚â•5, Notable ‚â•12, Significant ‚â•20, Severe ‚â•30.">Impact Score</div>
            <div class="value" id="susScore">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Highest forecast sustained wind speed within the selected time window.">Peak Speed</div>
            <div class="value" id="susPeak">-- mph</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Wind direction at the time of peak sustained speed.">Direction</div>
            <div class="value" id="susDir">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="0‚Äì1 multiplier for your property's directional exposure. N/NW = 1.0 (full open water fetch from ocean). S/SE ‚âà 0.1 (sheltered by shoreline and property). Applied as exposure^1.5 so high-exposure directions are disproportionately penalized.">Exposure Factor</div>
            <div class="value" id="susExposure">--</div>
          </div>
          <div class="row">
            <div class="label" data-tip="Forecast time when peak sustained wind is expected.">Peak Time</div>
            <div class="value" id="susTime">--</div>
          </div>
          <div class="small-note" id="susNote">Sustained = dock lines, outdoor use. Gust = structural stress.</div>
          </div>
        </div>

        <!-- 48-Hour Wind Forecast -->
        <div class="card col-12" data-collapse-key="48h_wind" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('48h_wind', this)">48-Hour Wind Forecast <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <canvas id="windChart"></canvas>
          </div>
        </div>
      </div>
    </section>

    <!-- ALMANAC VIEW -->
    <section id="almanacView" style="display:none;">
      <div class="grid">

        <!-- Tides full width -->
        <div class="card col-12" data-collapse-key="tides" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('tides', this)">&#127754; Tides &#8212; Salem Harbor <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
          <div id="tideGrid"></div>
          <div class="small-note" id="nextTideNote"></div>
          <canvas id="tideChart" style="margin-top:18px;max-height:200px;"></canvas>
          </div>
        </div>

        <!-- Dock Day Score -->
        <div class="card col-12" data-collapse-key="dock_day" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('dock_day', this)">‚öì Dock Day Score <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
            <div id="dockDayContent"></div>
          </div>
        </div>

        <!-- Buoy 44013 / Water Temp -->
        <div class="card col-12" data-collapse-key="buoy_44013" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('buoy_44013', this)">&#127754; Ocean Conditions <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:0;">

            <!-- Water temps -->
            <div style="padding-right:16px;border-right:1px solid rgba(255,255,255,0.08);">
              <div class="row">
                <div class="label" data-tip="Sea surface temperature from buoy 44013, 16mi ENE in open ocean. Typically 3‚Äì5¬∞F colder than Salem Harbor in summer ‚Äî buoy sits in deep open water while your harbor is shallow and enclosed, warming faster.">Water Temp</div>
                <div class="value" id="buoyWaterTemp">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="Air temperature measured at buoy 44013, 16mi ENE offshore.">Air Temp</div>
                <div class="value" id="buoyAirTemp">--</div>
              </div>
            </div>

            <!-- Wind & pressure -->
            <div style="padding:0 16px;border-right:1px solid rgba(255,255,255,0.08);">
              <div class="row">
                <div class="label" data-tip="Wind speed and direction measured at buoy 44013. Open ocean reading ‚Äî may differ from shore conditions.">Wind</div>
                <div class="value" id="buoyWind">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="Barometric pressure measured at buoy 44013. Useful cross-check against KBOS observed pressure.">Pressure</div>
                <div class="value" id="buoyPressure">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="Change in barometric pressure over the last 3 hours at the buoy. Rapid falls indicate approaching low pressure systems.">Tendency (3h)</div>
                <div class="value" id="buoyPtdy">--</div>
              </div>
            </div>

            <!-- Waves -->
            <div style="padding-left:16px;">
              <div class="row">
                <div class="label" data-tip="Significant wave height ‚Äî the average of the highest one-third of waves. Actual max waves may be 1.5‚Äì2√ó this value.">Wave Height</div>
                <div class="value" id="buoyWaveHt">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="Time in seconds between successive wave crests. Longer period (>10s) = swell from distant storms, smoother ride. Shorter period = choppy local wind waves.">Wave Period</div>
                <div class="value" id="buoyWavePeriod">--</div>
              </div>
            </div>

          </div>
          <div class="small-note" style="margin-top:8px;">Water temp is offshore (16mi ENE). Harbor temp typically 2‚Äì5¬∞F warmer in summer, similar in winter.</div>
          </div>
        </div>

        <!-- Sun full width, 3-column -->
        <div class="card col-12" data-collapse-key="sun" data-default-open="false">
          <div class="card-title card-title-collapsible" id="sunCardTitle" onclick="toggleCard('sun', this)">&#9728;&#65039; Sun <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:0;">

            <!-- Summary column -->
            <div style="padding-right:16px;border-right:1px solid rgba(255,255,255,0.08);">
              <div style="font-size:3.5rem;line-height:1;margin-bottom:6px;" id="sunEmoji">&#9728;&#65039;</div>
              <div style="font-weight:900;font-size:1rem;color:rgba(255,255,255,0.9);margin-bottom:4px;" id="sunStatus">--</div>
              <div style="font-size:0.88rem;color:rgba(255,255,255,0.6);font-weight:800;" id="daylight">-- daylight</div>
              <div style="font-size:0.85rem;color:rgba(255,255,255,0.5);margin-top:6px;" id="solarNoonLabel">Solar noon: --</div>
            </div>

            <!-- Times column -->
            <div style="padding:0 16px;border-right:1px solid rgba(255,255,255,0.08);">
              <div class="row">
                <div class="label" data-tip="Time of sunrise at your location, calculated from your coordinates.">Sunrise</div>
                <div class="value" id="sunrise">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="Time of sunset at your location. Your NW-facing dock gets direct sun right up to sunset.">Sunset</div>
                <div class="value" id="sunset">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="When the sun is 6¬∞ below the horizon. Enough light for outdoor activities without artificial light. Begins the civil twilight period.">Civil Dawn</div>
                <div class="value" id="civilDawn">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="When the sun reaches 6¬∞ below the horizon after sunset. End of civil twilight ‚Äî artificial light needed for outdoor activities.">Civil Dusk</div>
                <div class="value" id="civilDusk">--</div>
              </div>
            </div>

            <!-- Position column -->
            <div style="padding-left:16px;">
              <div class="row">
                <div class="label" data-tip="Compass bearing of the sun right now. Your dock faces 315¬∞ NW ‚Äî the sun illuminates the dock face directly near sunset in summer when the bearing approaches 315¬∞.">Direction</div>
                <div class="value" id="sunAzimuth">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="Current angle of the sun above the horizon. Below 0¬∞ = below horizon. Above 45¬∞ = high sun, strong shadows.">Altitude</div>
                <div class="value" id="sunAltitude">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="The hour after sunrise when sunlight is warm, soft, and low-angled. Ideal for photography and beautiful light conditions.">Golden Hour AM</div>
                <div class="value" id="goldenHourAM">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="The hour before sunset. Same warm, diffuse light quality as the morning golden hour.">Golden Hour PM</div>
                <div class="value" id="goldenHourPM">--</div>
              </div>
            </div>

          </div>
          <div class="small-note" id="sunNote" style="margin-top:10px;"></div>
          </div><!-- /card-body sun -->
        </div><!-- /card sun -->

        <!-- Sunset Quality -->
        <div class="card col-12" data-collapse-key="sunset_quality" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('sunset_quality', this)">üåÖ Sunset Quality Forecast <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
            <div id="sunsetQualityContent"></div>
          </div>
        </div>

        <!-- Moon ‚Äî full width -->
        <div class="card col-12" data-collapse-key="moon" data-default-open="false">
          <div class="card-title card-title-collapsible" id="moonCardTitle" onclick="toggleCard('moon', this)">&#127769; Moon <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body" style="display:none;">
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:0;">

            <!-- Phase column -->
            <div style="padding-right:16px;border-right:1px solid rgba(255,255,255,0.08);">
              <div style="font-size:3.5rem;line-height:1;margin-bottom:6px;" id="moonEmoji">&#127769;</div>
              <div style="font-weight:900;font-size:1rem;color:rgba(255,255,255,0.9);margin-bottom:4px;" id="moonPhaseName">--</div>
              <div style="font-size:0.88rem;color:rgba(255,255,255,0.6);font-weight:800;" id="moonIllumination">-- % illuminated</div>
            </div>

            <!-- Rise / Set column -->
            <div style="padding:0 16px;border-right:1px solid rgba(255,255,255,0.08);">
              <div class="row">
                <div class="label" data-tip="Time the moon rises above the horizon today at your location.">Moonrise</div>
                <div class="value" id="moonrise">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="Time the moon sets below the horizon today at your location.">Moonset</div>
                <div class="value" id="moonset">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="Date of the next full moon. Both full and new moons produce spring tides ‚Äî larger tidal range with higher highs and lower lows. Quarter moons produce neap tides with smaller range.">Next Full Moon</div>
                <div class="value" id="nextFullMoon">--</div>
              </div>
            </div>

            <!-- Position column -->
            <div style="padding-left:16px;">
              <div class="row">
                <div class="label" data-tip="Current compass bearing of the moon.">Direction</div>
                <div class="value" id="moonAzimuth">--</div>
              </div>
              <div class="row">
                <div class="label" data-tip="Current angle of the moon above the horizon. Negative = below horizon.">Altitude</div>
                <div class="value" id="moonAltitude">--</div>
              </div>
              <div class="row" style="border-bottom:none;">
                <div class="label" data-tip="Percentage of the moon's face illuminated. 0% = new moon, 100% = full moon. Affects nighttime visibility and tidal range.">Visible</div>
                <div class="value" id="moonVisible">--</div>
              </div>
            </div>

          </div>
          <div class="small-note" id="moonNote" style="margin-top:10px;"></div>
          </div><!-- /card-body moon -->
        </div><!-- /card moon -->

        <!-- Solar System -->
        <div class="card col-12" data-collapse-key="solar_system" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('solar_system', this)">ü™ê Solar System Tonight <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
            <div id="solarSystemGrid"></div>
            <div id="solarSystemNote" style="font-size:0.75rem;color:rgba(255,255,255,0.35);margin-top:12px;"></div>
          </div>
        </div>

        <!-- Frost / Freeze Tracker -->
        <div class="card col-12" data-collapse-key="frost_freeze" data-default-open="false">
          <div class="card-title card-title-collapsible" onclick="toggleCard('frost_freeze', this)">üå°Ô∏è Frost &amp; Freeze Tracker <span class="collapse-chevron">&#9660;</span></div>
          <div class="card-body">
          <div id="frostTracker" style="margin-top:6px;"></div>
          </div>
        </div>

        <!-- Water Temp Logger ‚Äî hidden until calibration data is sufficient -->
        <div id="waterTempLoggerCard" style="display:none;" class="card col-12">
          <div class="card-title">üå°Ô∏è Water Temp Calibration Logger</div>
          <div class="card-body">
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;flex-wrap:wrap;">
              <input id="wtLogTemp" type="number" step="0.5" placeholder="Water temp ¬∞F"
                style="background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);
                       color:rgba(255,255,255,0.9);border-radius:8px;padding:7px 12px;
                       font-size:0.9rem;width:140px;">
              <button onclick="logWaterTemp()"
                style="background:rgba(100,160,255,0.2);border:1px solid rgba(100,160,255,0.4);
                       color:rgba(160,200,255,0.95);border-radius:8px;padding:7px 16px;
                       font-weight:800;font-size:0.85rem;cursor:pointer;">
                Log Reading
              </button>
              <span id="wtLogStatus" style="font-size:0.8rem;color:rgba(255,255,255,0.4);"></span>
            </div>
            <div id="wtLogTable" style="font-size:0.78rem;color:rgba(255,255,255,0.6);"></div>
          </div>
        </div>

      </div>
    </section>

    <!-- SOURCES VIEW -->
    <section id="sourcesView" style="display:none;">
      <div class="grid">
        <div class="card col-12">
          <div class="card-title">üì° Data Sources &amp; Status</div>
          <div id="sourcesTable" style="margin-top:8px;"></div>
        </div>
      </div>
    </section>

    <!-- RADAR VIEW -->
    <section id="radarView" style="display:none;">
      <div class="grid">
        <div class="card col-12" style="padding:0;overflow:hidden;border-radius:18px;">

          <!-- Controls bar -->
          <div id="radarControls" style="
            display:flex;align-items:center;gap:12px;flex-wrap:wrap;
            padding:12px 16px;background:rgba(255,255,255,0.05);
            border-bottom:1px solid rgba(255,255,255,0.08);">

            <span style="font-weight:900;font-size:0.9rem;color:rgba(255,255,255,0.85);">
              &#127941; Radar
            </span>

            <!-- Layer selector -->
            <div style="display:flex;gap:6px;margin-left:4px;">
              <button onclick="setRadarLayer('radar')"   id="btnLayerRadar"
                class="radar-btn radar-btn-active">Radar</button>
              <button onclick="setRadarLayer('satellite')" id="btnLayerSat"
                class="radar-btn">Satellite</button>
            </div>

            <!-- Spacer -->
            <div style="flex:1;"></div>

            <!-- Timestamp -->
            <span id="radarTimestamp" style="font-size:0.8rem;color:rgba(255,255,255,0.5);font-weight:700;"></span>

            <!-- Play/Pause -->
            <button id="radarPlayBtn" onclick="radarTogglePlay()"
              style="background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);
                     color:rgba(255,255,255,0.85);border-radius:999px;padding:5px 14px;
                     font-size:0.82rem;font-weight:900;cursor:pointer;">
              &#9654; Play
            </button>

          </div>

          <!-- Map -->
          <div id="radarMap" style="height:520px;width:100%;background:#0b1220;"></div>

          <!-- Frame scrubber -->
          <div style="padding:8px 16px 10px;background:rgba(255,255,255,0.03);
                      border-top:1px solid rgba(255,255,255,0.06);">
            <input type="range" id="radarScrubber" min="0" max="0" value="0"
              oninput="radarScrubTo(this.value)"
              style="width:100%;accent-color:rgba(100,180,255,0.9);cursor:pointer;">
            <div style="display:flex;justify-content:space-between;
                        font-size:0.75rem;color:rgba(255,255,255,0.35);font-weight:700;margin-top:2px;">
              <span id="radarScrubStart">--</span>
              <span style="color:rgba(255,255,255,0.45);">&#9664; Past &nbsp;|&nbsp; <span style="color:rgba(100,255,180,0.6);">Nowcast</span> &#9654;</span>
              <span id="radarScrubEnd">--</span>
            </div>
          </div>

        </div>
      </div>
    </section>

  </div>

  <script>
    // ======================================================
    // Tab behavior ‚Äî Weather / Wind / Almanac
    // ======================================================
    function showTab(which) {
      const views = { weather: "weatherView", wind: "windView", almanac: "almanacView", radar: "radarView", sources: "sourcesView" };
      const tabs  = { weather: "tabWeather",  wind: "tabWind",  almanac: "tabAlmanac",  radar: "tabRadar",  sources: "tabSources" };
      Object.keys(views).forEach(k => {
        const v = document.getElementById(views[k]);
        const t = document.getElementById(tabs[k]);
        if (v) v.style.display = (k === which) ? "" : "none";
        if (t) {
          t.classList.toggle("active", k === which);
          t.setAttribute("aria-selected", String(k === which));
        }
      });
      try { localStorage.setItem("activeTab", which); } catch(e) {}
      if (which === "radar") {
        // Wait for browser to paint the div before Leaflet measures it
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            initRadar();
            if (radarMap) radarMap.invalidateSize();
          });
        });
      }
      // Scroll so tab content is visible below sticky header
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    (function restoreTab() {
      try {
        const t = localStorage.getItem("activeTab");
        if (["wind","almanac","radar","sources"].includes(t)) showTab(t);
      } catch(e) {}
    })();

    // ======================================================
    // Formatting helpers
    // ======================================================
    const weatherEmoji = {
      0: "&#9728;&#65039;", 1: "&#127780;&#65039;", 2: "&#9925;", 3: "&#9729;&#65039;",
      45: "&#127787;&#65039;", 48: "&#127787;&#65039;",
      51: "&#127782;&#65039;", 53: "&#127783;&#65039;", 55: "&#127783;&#65039;",
      61: "&#127783;&#65039;", 63: "&#127783;&#65039;", 65: "&#127783;&#65039;",
      71: "&#127784;&#65039;", 73: "&#127784;&#65039;", 75: "&#127784;&#65039;",
      77: "&#127784;&#65039;", 80: "&#127782;&#65039;", 81: "&#127782;&#65039;", 82: "&#127783;&#65039;",
      85: "&#127784;&#65039;", 86: "&#127784;&#65039;",
      95: "&#9928;&#65039;", 96: "&#9928;&#65039;", 99: "&#9928;&#65039;"
    };

    const weatherDesc = {
      0: "Clear", 1: "Mostly Clear", 2: "Partly Cloudy", 3: "Overcast",
      45: "Fog", 48: "Freezing Fog",
      51: "Light Drizzle", 53: "Drizzle", 55: "Heavy Drizzle",
      61: "Light Rain", 63: "Rain", 65: "Heavy Rain",
      71: "Light Snow", 73: "Snow", 75: "Heavy Snow",
      77: "Snow Grains", 80: "Light Showers", 81: "Showers", 82: "Heavy Showers",
      85: "Light Snow Showers", 86: "Heavy Snow Showers",
      95: "Thunderstorm", 96: "Thunderstorm + Hail", 99: "Severe Thunderstorm"
    };

    function fmtLocal(dt) {
      if (!dt) return "--";
      const d = new Date(dt);
      if (isNaN(d.getTime())) return "--";
      return d.toLocaleString("en-US", { month: "short", day: "numeric", hour: "numeric", minute: "2-digit" });
    }

    // Single canonical compass function ‚Äî replaces both old degreesToCompass and degToCompass
    function toCompass(deg, withDeg = true) {
      if (deg == null || isNaN(deg)) return "--";
      const d = ((deg % 360) + 360) % 360;
      const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
      const label = dirs[Math.round(d / 22.5) % 16];
      return withDeg ? `${Math.round(d)}¬∞ ${label}` : label;
    }

    // ======================================================
    // Wind Exposure Table (mirrors collector.py exactly)
    // ======================================================
    const WIND_EXPOSURE_TABLE = [
      [  0,  20, 1.00],
      [ 20,  60, 0.90],
      [ 60,  90, 0.70],
      [ 90, 130, 0.50],
      [130, 165, 0.20],
      [165, 200, 0.10],
      [200, 255, 0.05],
      [255, 285, 0.30],
      [285, 315, 0.70],
      [315, 360, 0.95],
    ];

    const WORRY_NOTICEABLE  =  5;
    const WORRY_NOTABLE     = 12;
    const WORRY_SIGNIFICANT = 20;
    const WORRY_SEVERE      = 30;

    function getExposureFactor(deg) {
      const d = ((deg % 360) + 360) % 360;
      for (const [minD, maxD, factor] of WIND_EXPOSURE_TABLE) {
        if (minD <= maxD) {
          if (d >= minD && d < maxD) return factor;
        } else {
          if (d >= minD || d < maxD) return factor;
        }
      }
      return 0.5;
    }

    function worryScore(speed, expFactor) {
      return speed * Math.pow(expFactor, 1.5);
    }

    function worryLevel(score) {
      if (score >= WORRY_SEVERE)      return { label: "SEVERE",      cls: "severe"      };
      if (score >= WORRY_SIGNIFICANT) return { label: "SIGNIFICANT", cls: "significant" };
      if (score >= WORRY_NOTABLE)     return { label: "NOTABLE",     cls: "notable"     };
      if (score >= WORRY_NOTICEABLE)  return { label: "BREEZY",      cls: "breezy"      };
      return                                 { label: "CALM",         cls: "calm"        };
    }

    function computePeakWorry(hourly, windowHours, useGusts) {
      const values = useGusts ? (hourly?.wind_gusts || []) : (hourly?.wind_speed || []);
      const dirs   = hourly?.wind_direction || [];
      const times  = hourly?.times || [];
      const n = Math.min(windowHours, values.length, dirs.length);

      let bestScore = -1, bestIdx = -1;
      for (let i = 0; i < n; i++) {
        const v = values[i], d = dirs[i];
        if (v == null || d == null) continue;
        const ef = getExposureFactor(d);
        const ws = worryScore(v, ef);
        if (ws > bestScore) { bestScore = ws; bestIdx = i; }
      }
      if (bestIdx < 0) return null;

      const d = dirs[bestIdx];
      const ef = getExposureFactor(d);
      return {
        speed:          values[bestIdx],
        directionDeg:   d,
        exposureFactor: ef,
        score:          worryScore(values[bestIdx], ef),
        timeISO:        times[bestIdx] || null
      };
    }

    // ======================================================
    // Charts
    // ======================================================
    let tempPrecipChart = null;
    let windChartObj    = null;

    function buildTempPrecipChart(times, temps, pop, wetBulbs) {
      const labels = times.map(t => new Date(t).toLocaleTimeString("en-US", { hour: "numeric" }));
      const ctx    = document.getElementById("tempPrecipChart").getContext("2d");
      if (tempPrecipChart) tempPrecipChart.destroy();

      // Color each precip bar by wet bulb precip type
      // Snow = white/light grey, Mixed = purple/slate, Freezing rain = orange, Rain = blue
      const precipColors = (wetBulbs || []).map((wb, i) => {
        const p = pop[i] ?? 0;
        if (p < 5) return "rgba(255,255,255,0.06)";   // negligible ‚Äî faint
        if (wb == null) return "rgba(80,140,255,0.55)"; // unknown ‚Äî default blue
        if (wb <= 28)   return "rgba(230,240,255,0.90)"; // snow ‚Äî near white
        if (wb <= 32)   return "rgba(200,215,255,0.80)"; // snow likely ‚Äî light grey-blue
        if (wb <= 35)   return "rgba(160,100,220,0.80)"; // mixed/slush ‚Äî purple
        if (wb <= 38)   return "rgba(255,140,40,0.80)";  // freezing rain ‚Äî orange
        return          "rgba(60,130,255,0.70)";          // rain ‚Äî blue
      });

      tempPrecipChart = new Chart(ctx, {
        data: {
          labels,
          datasets: [
            {
              type: "line",
              label: "Temp (¬∞F)",
              data: temps.map(v => v ?? null),
              yAxisID: "y",
              tension: 0.25,
              borderColor: "rgba(255,180,80,0.9)",
              backgroundColor: "transparent",
              pointRadius: 0,
            },
            {
              type: "bar",
              label: "Precip %",
              data: pop.map(v => v ?? null),
              yAxisID: "y1",
              backgroundColor: precipColors,
              borderColor: "transparent",
              borderRadius: 3,
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { labels: { color: "rgba(255,255,255,0.8)" } },
            tooltip: {
              callbacks: {
                afterLabel: (ctx) => {
                  if (ctx.datasetIndex === 1) {
                    const wb = wetBulbs?.[ctx.dataIndex];
                    if (wb == null) return "";
                    if (wb <= 28)  return "‚ùÑÔ∏è Snow";
                    if (wb <= 32)  return "üå® Snow likely";
                    if (wb <= 35)  return "üü£ Mixed/slush";
                    if (wb <= 38)  return "üü† Freezing rain possible";
                    return "üîµ Rain";
                  }
                  return "";
                }
              }
            }
          },
          scales: {
            x:  { ticks: { color: "rgba(255,255,255,0.7)" }, grid: { color: "rgba(255,255,255,0.06)" } },
            y:  { ticks: { color: "rgba(255,255,255,0.7)" }, grid: { color: "rgba(255,255,255,0.06)" } },
            y1: { position: "right", min: 0, max: 100,
                  ticks: { color: "rgba(255,255,255,0.7)" }, grid: { drawOnChartArea: false } }
          }
        }
      });
    }

    function windColor(mph) {
      if (mph == null) return "rgba(255,255,255,0.08)";
      if (mph < 10)   return "rgba(80,200,120,0.85)";
      if (mph < 20)   return "rgba(220,200,60,0.85)";
      if (mph < 30)   return "rgba(240,140,40,0.85)";
      if (mph < 40)   return "rgba(220,60,60,0.85)";
      return                 "rgba(160,60,220,0.85)";
    }

    function buildWindChart(times, speeds, gusts) {
      const labels      = times.map(t => new Date(t).toLocaleTimeString("en-US", { hour: "numeric" }));
      const ctx         = document.getElementById("windChart").getContext("2d");
      if (windChartObj) windChartObj.destroy();
      const speedColors = speeds.map(v => windColor(v));
      windChartObj = new Chart(ctx, {
        data: {
          labels,
          datasets: [
            {
              type: "bar",
              label: "Wind (mph)",
              data: speeds.map(v => v ?? null),
              yAxisID: "y",
              backgroundColor: speedColors,
              borderColor: "transparent",
              borderRadius: 3,
            },
            {
              type: "line",
              label: "Gust (mph)",
              data: gusts.map(v => v ?? null),
              yAxisID: "y",
              tension: 0.25,
              borderColor: "rgba(255,180,100,0.8)",
              backgroundColor: "transparent",
              pointRadius: 0,
              borderWidth: 2,
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { labels: { color: "rgba(255,255,255,0.8)" } },
            tooltip: {
              callbacks: {
                afterLabel: (ctx) => {
                  if (ctx.datasetIndex === 0) {
                    const v = ctx.raw;
                    if (v == null) return "";
                    if (v < 10)  return "Calm";
                    if (v < 20)  return "Breezy";
                    if (v < 30)  return "Windy";
                    if (v < 40)  return "Strong";
                    return "Dangerous";
                  }
                  return "";
                }
              }
            }
          },
          scales: {
            x: { ticks: { color: "rgba(255,255,255,0.7)" }, grid: { color: "rgba(255,255,255,0.06)" } },
            y: { ticks: { color: "rgba(255,255,255,0.7)" }, grid: { color: "rgba(255,255,255,0.06)" } }
          }
        }
      });
    }

    // ======================================================
    // Rendering functions
    // ======================================================
    function renderFrostTracker(frost) {
      const el = document.getElementById("frostTracker");
      if (!el || !frost) return;
      if (!frost.season_start) {
        el.innerHTML = '<div style="color:rgba(255,255,255,0.4);font-size:0.85rem;">No frost data yet ‚Äî will populate after first overnight run.</div>';
        return;
      }

      const [sy, sm, sd] = frost.season_start.split("-").map(Number);
      const seasonStart = new Date(sy, sm-1, sd).toLocaleDateString("en-US", { month:"short", day:"numeric", year:"numeric" });
      const fmt = d => d ? new Date(d).toLocaleDateString("en-US", { month:"short", day:"numeric" }) : "None this season";

      const upcoming = frost.upcoming_freeze_days || [];
      const upcomingHtml = upcoming.length === 0
        ? '<span style="color:rgba(255,255,255,0.4);">None in 10-day forecast</span>'
        : upcoming.map(u => {
            const label = u.min_f <= 20 ? "‚ùÑÔ∏è‚ùÑÔ∏è" : u.min_f <= 28 ? "‚ùÑÔ∏è" : "üå°Ô∏è";
            const d = new Date(u.date).toLocaleDateString("en-US", { weekday:"short", month:"short", day:"numeric" });
            return `<span style="margin-right:12px;">${label} ${d} (${u.min_f}¬∞F)</span>`;
          }).join("");

      el.innerHTML = `
        <div style="font-size:0.78rem;color:rgba(255,255,255,0.4);margin-bottom:10px;">Season from ${seasonStart}</div>
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:14px;">
          <div style="background:rgba(100,180,255,0.08);border:1px solid rgba(100,180,255,0.18);border-radius:10px;padding:10px;text-align:center;">
            <div style="font-size:1.8rem;font-weight:900;color:rgba(180,220,255,0.9);">${frost.freeze_days ?? 0}</div>
            <div style="font-size:0.78rem;color:rgba(255,255,255,0.5);margin-top:2px;">Freeze days</div>
            <div style="font-size:0.72rem;color:rgba(255,255,255,0.35);margin-top:3px;">min ‚â§ 32¬∞F</div>
            <div style="font-size:0.72rem;color:rgba(255,255,255,0.4);margin-top:4px;">Last: ${fmt(frost.last_freeze)}</div>
          </div>
          <div style="background:rgba(60,120,255,0.08);border:1px solid rgba(60,120,255,0.18);border-radius:10px;padding:10px;text-align:center;">
            <div style="font-size:1.8rem;font-weight:900;color:rgba(140,180,255,0.9);">${frost.hard_freeze_days ?? 0}</div>
            <div style="font-size:0.78rem;color:rgba(255,255,255,0.5);margin-top:2px;">Hard freeze days</div>
            <div style="font-size:0.72rem;color:rgba(255,255,255,0.35);margin-top:3px;">min ‚â§ 28¬∞F</div>
            <div style="font-size:0.72rem;color:rgba(255,255,255,0.4);margin-top:4px;">Last: ${fmt(frost.last_hard)}</div>
          </div>
          <div style="background:rgba(20,60,180,0.08);border:1px solid rgba(20,60,180,0.25);border-radius:10px;padding:10px;text-align:center;">
            <div style="font-size:1.8rem;font-weight:900;color:rgba(100,140,255,0.9);">${frost.severe_days ?? 0}</div>
            <div style="font-size:0.78rem;color:rgba(255,255,255,0.5);margin-top:2px;">Severe freeze days</div>
            <div style="font-size:0.72rem;color:rgba(255,255,255,0.35);margin-top:3px;">min ‚â§ 20¬∞F</div>
            <div style="font-size:0.72rem;color:rgba(255,255,255,0.4);margin-top:4px;">Last: ${fmt(frost.last_severe)}</div>
          </div>
        </div>
        <div style="font-size:0.82rem;font-weight:800;color:rgba(255,255,255,0.55);margin-bottom:6px;">Upcoming freeze nights (10-day forecast):</div>
        <div style="font-size:0.82rem;color:rgba(180,210,255,0.8);line-height:1.8;">${upcomingHtml}</div>
      `;
    }

    // ======================================================
    // Solar System (VSOP87 truncated ‚Äî no API needed)
    // ======================================================
    // ======================================================
    // Sunset Quality Forecast
    // Algorithm based on SunsetWx methodology:
    //   Score = mid_cloud √ó (1 - low_cloud_penalty) √ó humidity_factor
    // Best sunsets: 30-70% mid/high cloud, <20% low cloud, dry air
    // ======================================================
    function renderSunsetQuality(data) {
      const el = document.getElementById("sunsetQualityContent");
      if (!el) return;

      const hourly  = data.hourly  || {};
      const daily   = data.daily   || {};
      const times   = hourly.times || [];
      const low     = hourly.cloud_cover_low  || [];
      const mid     = hourly.cloud_cover_mid  || [];
      const high    = hourly.cloud_cover_high || [];
      const total   = hourly.cloud_cover      || [];
      const humidity= hourly.humidity         || [];
      const sunsets = daily.sunset            || [];

      if (!times.length || !sunsets.length) {
        el.innerHTML = `<div style="color:rgba(255,255,255,0.4);font-size:0.85rem;">Sunset data unavailable</div>`;
        return;
      }

      // Score each day's sunset window (sunset-30min to sunset+20min)
      const scores = [];
      for (let di = 0; di < Math.min(sunsets.length, 5); di++) {
        const sunsetISO = sunsets[di];
        if (!sunsetISO) continue;
        const sunsetMs = new Date(sunsetISO).getTime();

        // Find hourly indices within the sunset window
        const windowIndices = [];
        for (let i = 0; i < times.length; i++) {
          const tMs = new Date(times[i]).getTime();
          if (tMs >= sunsetMs - 30*60000 && tMs <= sunsetMs + 20*60000) {
            windowIndices.push(i);
          }
        }
        // If sunset already passed and window is empty, use nearest available hour
        if (!windowIndices.length) {
          let best = -1, bestDiff = Infinity;
          for (let i = 0; i < times.length; i++) {
            const diff = Math.abs(new Date(times[i]).getTime() - sunsetMs);
            if (diff < bestDiff) { bestDiff = diff; best = i; }
          }
          if (best >= 0 && bestDiff < 4*3600000) windowIndices.push(best);
        }
        if (!windowIndices.length) continue;

        // Average cloud layers and humidity over window
        const avg = arr => {
          const vals = windowIndices.map(i => arr[i]).filter(v => v != null);
          return vals.length ? vals.reduce((a,b) => a+b, 0) / vals.length : null;
        };

        const avgLow  = avg(low)  ?? 0;
        const avgMid  = avg(mid)  ?? 0;
        const avgHigh = avg(high) ?? 0;
        const avgHum  = avg(humidity) ?? 50;

        // Scoring algorithm
        // Mid clouds 30-70% are ideal; high clouds add some color; low clouds block
        const midScore  = avgMid  <= 70 ? avgMid / 70 : (100 - avgMid) / 30;  // peaks at 70%
        const highBonus = Math.min(avgHigh, 60) / 60 * 0.3;                    // up to 0.3 bonus
        const lowPenalty= Math.min(avgLow / 80, 1.0);                          // kills score if overcast low
        const humFactor = 1 - Math.max(0, (avgHum - 60)) / 80;                 // humidity penalty above 60%

        let score = (midScore * 0.7 + highBonus) * (1 - lowPenalty * 0.8) * humFactor;
        score = Math.max(0, Math.min(1, score));

        // Label
        let label, color, emoji;
        if (score >= 0.75)      { label = "Spectacular";  color = "rgba(255,160,40,0.95)";  emoji = "üî•"; }
        else if (score >= 0.55) { label = "Very Good";    color = "rgba(255,200,60,0.95)";  emoji = "üåÖ"; }
        else if (score >= 0.35) { label = "Good";         color = "rgba(255,220,100,0.9)";  emoji = "üå§Ô∏è"; }
        else if (score >= 0.18) { label = "Fair";         color = "rgba(180,180,180,0.8)";  emoji = "üå•Ô∏è"; }
        else                    { label = "Poor";         color = "rgba(120,120,120,0.6)";  emoji = "‚òÅÔ∏è"; }

        const sunsetDate = new Date(sunsetISO);
        const dayLabel   = di === 0 ? "Today" : di === 1 ? "Tomorrow"
          : sunsetDate.toLocaleDateString("en-US", { weekday:"short", month:"short", day:"numeric" });
        const timeLabel  = sunsetDate.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit" });

        scores.push({ dayLabel, timeLabel, score, label, color, emoji,
                      avgLow: avgLow.toFixed(0), avgMid: avgMid.toFixed(0),
                      avgHigh: avgHigh.toFixed(0), avgHum: avgHum.toFixed(0) });
      }

      if (!scores.length) {
        el.innerHTML = `<div style="color:rgba(255,255,255,0.4);font-size:0.85rem;">No sunset data in forecast window</div>`;
        return;
      }

      let html = `<div style="display:grid;grid-template-columns:repeat(${scores.length},1fr);gap:10px;margin-bottom:12px;">`;
      for (const s of scores) {
        const barW = Math.round(s.score * 100);
        html += `
          <div style="background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);
                      border-radius:10px;padding:16px 12px;text-align:center;">
            <div style="font-size:0.9rem;font-weight:800;color:rgba(255,255,255,0.6);margin-bottom:6px;">${s.dayLabel}</div>
            <div style="font-size:2rem;margin-bottom:6px;">${s.emoji}</div>
            <div style="font-size:1.05rem;font-weight:900;color:${s.color};margin-bottom:6px;">${s.label}</div>
            <div style="font-size:0.8rem;color:rgba(255,255,255,0.35);margin-bottom:10px;">Sunset ${s.timeLabel}</div>
            <!-- Score bar -->
            <div style="height:5px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden;margin-bottom:10px;">
              <div style="height:100%;width:${barW}%;background:${s.color};border-radius:3px;transition:width 0.4s;"></div>
            </div>
            <!-- Cloud breakdown -->
            <div style="font-size:0.78rem;color:rgba(255,255,255,0.4);line-height:2;">
              <span data-tip="Low clouds (below ~6,500 ft). High values block the sun from lighting upper clouds ‚Äî kills color.">Low ${s.avgLow}%</span> ¬∑
              <span data-tip="Mid-level clouds (6,500‚Äì20,000 ft). The sweet spot for sunset color ‚Äî 30‚Äì70% is ideal.">Mid ${s.avgMid}%</span> ¬∑
              <span data-tip="High clouds (above 20,000 ft, cirrus). Add soft color and atmosphere when mid clouds are present.">High ${s.avgHigh}%</span>
            </div>
          </div>`;
      }
      html += `</div>`;
      html += `<div style="font-size:0.78rem;color:rgba(255,255,255,0.3);margin-top:4px;">
        Score based on mid-level cloud fraction, low cloud obstruction, and humidity.
        Best conditions: 30‚Äì70% mid cloud, &lt;20% low cloud, dry air.
        Your western water view is a significant advantage.
      </div>`;

      el.innerHTML = html;
    }

    function renderSolarSystem() {
      const el = document.getElementById("solarSystemGrid");
      if (!el) return;

      const now   = new Date();
      const jd    = 2440587.5 + now.getTime() / 86400000;
      const T     = (jd - 2451545.0) / 36525.0;

      // Planet orbital elements [L0, L1, a, e0, e1, i0, i1, Om0, Om1, w0, w1]
      const EL = {
        Mercury: [252.250906,149474.0722491,0.387098310,0.20563175, 0.000020407, 7.004986, 0.0018215,48.330893,1.1861883, 77.456119,1.5564776],
        Venus:   [181.979801, 58519.2130302,0.723329820,0.00677188,-0.000047766, 3.394662, 0.0010037,76.679920,0.9011190,131.563703,1.4022288],
        Mars:    [355.433000, 19141.6964471,1.523679342,0.09340062, 0.000090483, 1.849726,-0.0006011,49.558093,0.7720959,336.060234,1.8410449],
        Jupiter: [ 34.351519,  3036.3027748,5.202603209,0.04849485, 0.000163244, 1.303270,-0.0054966,100.464407,1.0209774,14.331207,1.6126352],
        Saturn:  [ 50.077444,  1223.5110686,9.554909192,0.05550825,-0.000346641, 2.488878, 0.0025515,113.665503,0.8770880,93.057237,1.9637613],
      };

      const EMOJIS = { Mercury:"‚òø", Venus:"‚ôÄÔ∏è", Mars:"‚ôÇÔ∏è", Jupiter:"‚ôÉ", Saturn:"ü™ê" };
      const COLORS = {
        Mercury:"rgba(180,160,130,0.9)",
        Venus:  "rgba(255,220,100,0.9)",
        Mars:   "rgba(220,80,60,0.9)",
        Jupiter:"rgba(200,160,100,0.9)",
        Saturn: "rgba(210,190,130,0.9)",
      };

      const r2d = r => r * 180 / Math.PI;
      const d2r = d => d * Math.PI / 180;

      // Earth heliocentric position
      const M_e  = d2r(((357.529092 + 35999.0502909*T) % 360 + 360) % 360);
      const e_e  = 0.016708617 - 0.000042037*T;
      let   E_e  = M_e;
      for (let i=0;i<10;i++) E_e -= (E_e - e_e*Math.sin(E_e) - M_e)/(1 - e_e*Math.cos(E_e));
      const w_e  = d2r(102.937348 + 1.7195366*T);
      const xe0  = 1.000001018*(Math.cos(E_e) - e_e);
      const ye0  = 1.000001018*Math.sqrt(1-e_e*e_e)*Math.sin(E_e);
      const xe   = Math.cos(w_e)*xe0 - Math.sin(w_e)*ye0;
      const ye   = Math.sin(w_e)*xe0 + Math.cos(w_e)*ye0;

      // Greenwich Sidereal Time & Local Sidereal Time
      const GMST = ((280.46061837 + 360.98564736629*(jd-2451545.0) + 0.000387933*T*T) % 360 + 360) % 360;
      const LST  = (GMST + HOME_LON + 360) % 360;
      const LAT  = d2r(HOME_LAT);
      const eps  = d2r(23.439291 - 0.013004*T);

      const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];

      const results = [];

      for (const [name, el] of Object.entries(EL)) {
        const L   = d2r(((el[0] + el[1]*T) % 360 + 360) % 360);
        const a   = el[2];
        const e   = el[3] + el[4]*T;
        const inc = d2r(el[5] + el[6]*T);
        const Om  = d2r(el[7] + el[8]*T);
        const w   = d2r(el[9] + el[10]*T);
        const M   = ((L - w) % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
        let   E   = M;
        for (let i=0;i<10;i++) E -= (E - e*Math.sin(E) - M)/(1 - e*Math.cos(E));
        const xo  = a*(Math.cos(E) - e);
        const yo  = a*Math.sqrt(1-e*e)*Math.sin(E);
        const cOm=Math.cos(Om),sOm=Math.sin(Om),cw=Math.cos(w-Om),sw=Math.sin(w-Om),ci=Math.cos(inc),si=Math.sin(inc);
        const xh=(cOm*cw-sOm*sw*ci)*xo+(-cOm*sw-sOm*cw*ci)*yo;
        const yh=(sOm*cw+cOm*sw*ci)*xo+(-sOm*sw+cOm*cw*ci)*yo;
        const zh=si*(sw*xo+cw*yo);
        const gx=xh-xe, gy=yh-ye, gz=zh;
        const dist=Math.sqrt(gx*gx+gy*gy+gz*gz);
        // Equatorial
        const xeq=gx, yeq=gy*Math.cos(eps)-gz*Math.sin(eps), zeq=gy*Math.sin(eps)+gz*Math.cos(eps);
        const ra  =((r2d(Math.atan2(yeq,xeq))%360)+360)%360;
        const dec =r2d(Math.asin(zeq/dist));
        // Elongation
        const sx=-xe,sy=-ye,sz=0;
        const sdist=Math.sqrt(sx*sx+sy*sy+sz*sz);
        const dot=Math.max(-1,Math.min(1,(gx*sx+gy*sy+gz*sz)/(dist*sdist)));
        const elong=r2d(Math.acos(dot));
        // Alt/Az
        const HA = d2r(((LST - ra) % 360 + 360) % 360);
        const decR=d2r(dec);
        const alt =r2d(Math.asin(Math.sin(LAT)*Math.sin(decR)+Math.cos(LAT)*Math.cos(decR)*Math.cos(HA)));
        const azR =Math.atan2(-Math.cos(decR)*Math.sin(HA), Math.sin(decR)*Math.cos(LAT)-Math.cos(decR)*Math.cos(HA)*Math.sin(LAT));
        const az  =((r2d(azR)%360)+360)%360;
        const dirIdx=Math.round(az/22.5)%16;
        const visible = alt > 5 && elong > 15;
        results.push({name, emoji:EMOJIS[name], color:COLORS[name], alt:alt.toFixed(0), az:az.toFixed(0),
                      dir:dirs[dirIdx], dist:dist.toFixed(2), elong:elong.toFixed(0), visible});
      }

      // Sort: visible first (by altitude desc), then invisible (by elongation desc)
      results.sort((a,b) => {
        if (a.visible !== b.visible) return a.visible ? -1 : 1;
        return a.visible ? b.alt - a.alt : b.elong - a.elong;
      });

      const visCount = results.filter(r => r.visible).length;
      const timeStr  = now.toLocaleTimeString("en-US", {hour:"numeric", minute:"2-digit"});

      let html = `<div style="font-size:0.78rem;color:rgba(255,255,255,0.4);margin-bottom:12px;">
        ${visCount} planet${visCount!==1?"s":""} visible from Marblehead at ${timeStr}
      </div>`;

      html += `<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;">`;
      for (const p of results) {
        const dimStyle = p.visible ? "" : "opacity:0.35;";
        const borderColor = p.visible ? p.color.replace("0.9","0.4") : "rgba(255,255,255,0.08)";
        const altLabel = p.alt > 0
          ? `<span style="color:rgba(100,220,100,0.9);">${p.alt}¬∞ alt</span>`
          : `<span style="color:rgba(255,255,255,0.3);">below horizon</span>`;
        html += `
          <div style="${dimStyle}background:rgba(255,255,255,0.04);border:1px solid ${borderColor};border-radius:10px;padding:10px 8px;text-align:center;">
            <div style="font-size:1.5rem;margin-bottom:4px;">${p.emoji}</div>
            <div style="font-size:0.82rem;font-weight:900;color:${p.color};margin-bottom:6px;${!p.visible ? 'opacity:1;filter:saturate(0.5);' : ''}">${p.name}</div>
            <div style="font-size:0.75rem;margin-bottom:3px;">${altLabel}</div>
            ${p.alt > 0 ? `<div style="font-size:0.72rem;color:rgba(255,255,255,0.5);">${p.dir} ${p.az}¬∞</div>` : ""}
            <div style="font-size:0.7rem;color:rgba(255,255,255,0.3);margin-top:4px;">${p.elong}¬∞ from Sun</div>
            <div style="font-size:0.7rem;color:rgba(255,255,255,0.25);">${p.dist} AU</div>
          </div>`;
      }
      html += `</div>`;

      el.innerHTML = html;
      document.getElementById("solarSystemNote").textContent =
        "Positions calculated client-side using VSOP87 truncated series. Accurate to ~1¬∞.";
    }

    const SOURCE_META = {
      gfs_current:  { name: "GFS",          desc: "Global Forecast System ‚Äî current conditions baseline (NOAA)" },
      hrrr_hourly:  { name: "HRRR",         desc: "High-Resolution Rapid Refresh ‚Äî 48h hourly forecast, cloud layers, upper-air (NOAA)" },
      ecmwf_daily:  { name: "ECMWF",        desc: "European Centre model ‚Äî 10-day daily forecast (Open-Meteo)" },
      pws:          { name: "PWS",           desc: "Personal Weather Station KMAMARBL63 (Castle Hill, 0.25mi) ‚Äî via Weather Underground" },
      kbos:         { name: "KBOS",         desc: "Boston Logan Airport ASOS ‚Äî observed temp, pressure, tendency (NWS/aviationweather.gov)" },
      kbvy:         { name: "KBVY",         desc: "Beverly Airport ASOS ‚Äî observed temp, wind (NWS/aviationweather.gov)" },
      buoy_44013:   { name: "Buoy 44013",   desc: "NOAA Boston Buoy (16mi ENE) ‚Äî water temp, waves, offshore wind (NDBC)" },
      tides:        { name: "Tides",        desc: "NOAA CO-OPS tide predictions ‚Äî Salem Harbor station 8442645" },
      nws_forecast: { name: "NWS Forecast", desc: "NWS Boston text forecast and hourly details (api.weather.gov)" },
      nws_alerts:   { name: "NWS Alerts",   desc: "Active NWS watches, warnings, advisories for Marblehead (api.weather.gov)" },
    };

    const STATIC_SOURCES = [
      { name: "RainViewer",   desc: "Radar tile source ‚Äî smoothed NEXRAD composite with nowcast frames (rainviewer.com)" },
      { name: "Stadia Maps",  desc: "Dark basemap tiles for radar view (stadiamaps.com)" },
      { name: "SunCalc",      desc: "Client-side sun/moon position and phase calculations (mourner/suncalc)" },
      { name: "VSOP87",       desc: "Client-side planetary position calculations ‚Äî solar system card (truncated series, ~1¬∞ accuracy)" },
      { name: "Open-Meteo",   desc: "Cloud layer data (low/mid/high) for sunset quality forecast ‚Äî HRRR product" },
    ];

    function renderSources(sources, pwsStale) {
      if (!sources) return;
      const order = Object.keys(SOURCE_META);

      // Count errors for tab color
      let anyError = false;
      order.forEach(key => {
        const s = sources[key];
        if (s && s.status !== "ok") anyError = true;
      });
      const tabBtn = document.getElementById("tabSources");
      if (tabBtn) {
        tabBtn.style.background    = anyError ? "rgba(255,80,80,0.18)"  : "rgba(80,200,100,0.15)";
        tabBtn.style.borderColor   = anyError ? "rgba(255,80,80,0.45)"  : "rgba(80,200,100,0.4)";
        tabBtn.style.color         = anyError ? "rgba(255,180,180,0.95)" : "rgba(140,240,160,0.95)";
        tabBtn.textContent         = anyError ? "‚ö†Ô∏è Sources" : "‚úì Sources";
      }

      // Build sources table
      const table = document.getElementById("sourcesTable");
      if (!table) return;
      const pwsName = pwsStale ? "PWS (cached)" : "PWS (live)";

      table.innerHTML = `
        <div style="font-weight:900;font-size:0.8rem;color:rgba(255,255,255,0.4);letter-spacing:0.5px;margin-bottom:6px;">LIVE DATA SOURCES</div>
        <div style="display:grid;grid-template-columns:120px 60px 60px 1fr;gap:0;font-size:0.82rem;">
          <div style="font-weight:900;color:rgba(255,255,255,0.45);padding:6px 8px 6px 0;border-bottom:1px solid rgba(255,255,255,0.08);">Source</div>
          <div style="font-weight:900;color:rgba(255,255,255,0.45);padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.08);">Status</div>
          <div style="font-weight:900;color:rgba(255,255,255,0.45);padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.08);">Age</div>
          <div style="font-weight:900;color:rgba(255,255,255,0.45);padding:6px 0 6px 8px;border-bottom:1px solid rgba(255,255,255,0.08);">Description</div>
          ${order.map(key => {
            const s   = sources[key];
            if (!s) return "";
            const ok  = s.status === "ok";
            const age = typeof s.age_minutes === "number" ? s.age_minutes.toFixed(1) + "m" : "--";
            const meta = SOURCE_META[key];
            const name = key === "pws" ? pwsName : meta.name;
            return `
              <div style="font-weight:800;color:rgba(255,255,255,0.85);padding:8px 8px 8px 0;border-bottom:1px solid rgba(255,255,255,0.05);">${name}</div>
              <div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.05);">${ok ? "‚úÖ" : "‚ùå"}</div>
              <div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.05);color:${ok ? "rgba(255,255,255,0.7)" : "rgba(255,120,120,0.9)"};">${age}</div>
              <div style="padding:8px 0 8px 8px;border-bottom:1px solid rgba(255,255,255,0.05);color:rgba(255,255,255,0.55);">${meta.desc}${s.error ? `<span style="color:rgba(255,120,120,0.8);"> ‚Äî ${s.error}</span>` : ""}</div>
            `;
          }).join("")}
        </div>

        <div style="font-weight:900;font-size:0.8rem;color:rgba(255,255,255,0.4);letter-spacing:0.5px;margin:18px 0 6px;">CLIENT-SIDE &amp; STATIC SOURCES</div>
        <div style="display:grid;grid-template-columns:120px 1fr;gap:0;font-size:0.82rem;">
          <div style="font-weight:900;color:rgba(255,255,255,0.45);padding:6px 8px 6px 0;border-bottom:1px solid rgba(255,255,255,0.08);">Source</div>
          <div style="font-weight:900;color:rgba(255,255,255,0.45);padding:6px 0 6px 8px;border-bottom:1px solid rgba(255,255,255,0.08);">Description</div>
          ${STATIC_SOURCES.map(s => `
            <div style="font-weight:800;color:rgba(255,255,255,0.85);padding:8px 8px 8px 0;border-bottom:1px solid rgba(255,255,255,0.05);">${s.name}</div>
            <div style="padding:8px 0 8px 8px;border-bottom:1px solid rgba(255,255,255,0.05);color:rgba(255,255,255,0.55);">${s.desc}</div>
          `).join("")}
        </div>
      `;
    }

    let tideChartObj = null;

    // ======================================================
    // Dock Day Score
    // Dock floats when tide > DOCK_FLOAT_THRESHOLD_FT (above MLLW).
    // DOCK_TIDE_OFFSET_FT: correction to apply to predicted heights once
    //   empirical observed-vs-predicted data is collected. Default 0.0.
    // Dock faces 315¬∞ (NW) ‚Äî open water fetch in that direction.
    //   NW winds = directly onshore at dock = choppy.
    //   SE winds = offshore from dock = calm.
    // ======================================================
    const DOCK_FLOAT_THRESHOLD_FT = 1.5;   // ft above MLLW ‚Äî dock just floats
    const DOCK_TIDE_OFFSET_FT     = 0.0;   // empirical correction ‚Äî update when data available
    const DOCK_FACE_DEG           = 315;   // dock faces NW (summer solstice sunset bearing)
    const DOCK_USABLE_HOUR_START  =  7;    // before this hour = not usable
    const DOCK_USABLE_HOUR_END    = 20;    // after this hour = not usable

    function dockWindScore(windDirDeg, windSpeedKt) {
      // Returns 0 (bad) to 1 (good) based on wind angle AND speed
      if (windDirDeg == null || windSpeedKt == null) return 0.7;
      // Hard cap ‚Äî above 20 kt is unpleasant regardless of direction
      if (windSpeedKt > 20) return 0.0;
      if (windSpeedKt < 5)  return 1.0;   // calm = always fine
      // Angle between wind direction and dock face
      let diff = Math.abs(windDirDeg - DOCK_FACE_DEG);
      if (diff > 180) diff = 360 - diff;
      // 0¬∞ = wind from exactly dock direction (onshore) = score 0
      // 180¬∞ = wind from behind dock (offshore) = score 1
      const dirScore  = diff / 180;
      // Speed penalty: 5kt=mild, 15kt=significant, 20kt=hard cap above
      const speedPenalty = Math.min((windSpeedKt - 5) / 15, 1.0);
      // Onshore winds penalized harder at speed
      const onshoreBoost = dirScore < 0.33 ? 1.5 : 1.0;
      return Math.max(0, dirScore - speedPenalty * 0.5 * onshoreBoost);
    }

    function renderDockDay(data) {
      const el = document.getElementById("dockDayContent");
      if (!el) return;

      const curve   = (data.tide_curve || {});
      const ctimes  = curve.times   || [];
      const cheights= curve.heights || [];
      const hourly  = data.hourly   || {};
      const htimes  = hourly.times  || [];
      const htemps  = hourly.temperature || [];
      const hwind   = hourly.wind_speed  || [];
      const hwinddir= hourly.wind_direction || [];
      const hprecip = hourly.precipitation_probability || [];
      const buoy    = data.buoy     || {};
      const waterTempRaw = buoy.water_temp_f;

      if (!ctimes.length) {
        el.innerHTML = `<div style="color:rgba(255,255,255,0.4);font-size:0.85rem;">Tide curve data unavailable</div>`;
        return;
      }

      // Apply tide offset to all heights
      const correctedHeights = cheights.map(h => h + DOCK_TIDE_OFFSET_FT);

      // Helper: nearest hourly value to a given timestamp
      function nearestHourly(arr, targetMs) {
        let best = null, bestDiff = Infinity;
        for (let i = 0; i < htimes.length; i++) {
          const diff = Math.abs(new Date(htimes[i]).getTime() - targetMs);
          if (diff < bestDiff) { bestDiff = diff; best = arr[i]; }
        }
        return best;
      }

      // Build accessible windows for today and tomorrow
      const now   = new Date();
      const days  = [0, 1].map(d => {
        const date = new Date(now);
        date.setDate(date.getDate() + d);
        return date.toISOString().slice(0, 10);
      });

      const dayCards = [];

      for (const dayStr of days) {
        // Find all 6-min curve points for this day
        const dayPoints = [];
        for (let i = 0; i < ctimes.length; i++) {
          if (ctimes[i].startsWith(dayStr)) {
            dayPoints.push({ t: ctimes[i], h: correctedHeights[i] });
          }
        }
        if (!dayPoints.length) continue;

        // Find contiguous accessible windows where h > threshold
        const windows = [];
        let winStart = null;
        for (let i = 0; i < dayPoints.length; i++) {
          const accessible = dayPoints[i].h > DOCK_FLOAT_THRESHOLD_FT;
          if (accessible && winStart === null) winStart = i;
          if (!accessible && winStart !== null) {
            windows.push({ start: winStart, end: i - 1 });
            winStart = null;
          }
        }
        if (winStart !== null) windows.push({ start: winStart, end: dayPoints.length - 1 });

        // Filter to usable hours
        const usableWindows = windows.map(w => {
          // Trim to usable hours
          let s = w.start, e = w.end;
          while (s <= e) {
            const hr = new Date(dayPoints[s].t).getHours();
            if (hr >= DOCK_USABLE_HOUR_START) break;
            s++;
          }
          while (e >= s) {
            const hr = new Date(dayPoints[e].t).getHours();
            if (hr < DOCK_USABLE_HOUR_END) break;
            e--;
          }
          if (s > e) return null;
          const startMs = new Date(dayPoints[s].t).getTime();
          const endMs   = new Date(dayPoints[e].t).getTime();
          const durMin  = Math.round((endMs - startMs) / 60000);
          const midMs   = (startMs + endMs) / 2;

          // Weather at midpoint of window
          const temp    = nearestHourly(htemps,   midMs);
          const wspd    = nearestHourly(hwind,    midMs);
          const wdir    = nearestHourly(hwinddir, midMs);
          const precip  = nearestHourly(hprecip,  midMs);

          // Peak height during window
          const peakH = Math.max(...dayPoints.slice(s, e+1).map(p => p.h));

          // Wind score for dock
          const windSc = dockWindScore(wdir, wspd);

          // Temp score: 75¬∞F=1.0, 60¬∞F=0.5, 50¬∞F=0.1, below 45¬∞F=0
          // Hard reality: below 50¬∞F is not a dock day regardless of other factors
          const tempSc = temp == null ? 0.5 :
            temp < 45 ? 0.0 :
            temp < 55 ? Math.max(0, (temp - 45) / 20) :
            Math.min(1, (temp - 55) / 25 + 0.5);

          // Precip score
          const precipSc = precip == null ? 0.5 :
            Math.max(0, 1 - precip / 60);

          // Duration score: 3h+ = 1.0, 1h = 0.33
          const durSc = Math.min(1, durMin / 180);

          // Water temp score (from buoy) ‚Äî bonus factor
          const wtSc = waterTempRaw == null ? 0.5 :
            waterTempRaw < 50 ? 0.2 :
            waterTempRaw < 65 ? (waterTempRaw - 50) / 25 + 0.2 :
            1.0;

          // Overall score ‚Äî temp and wind are gatekeepers
          // If temp < 45 or wind > 20kt, score can't exceed 0.3
          const rawScore = windSc * 0.35 + tempSc * 0.35 + precipSc * 0.15 + durSc * 0.10 + wtSc * 0.05;
          const score = (temp != null && temp < 45) || (wspd != null && wspd > 20)
            ? Math.min(rawScore, 0.3)
            : rawScore;

          // Wind direction label relative to dock
          let windRelLabel = "";
          if (wdir != null) {
            let diff = Math.abs(wdir - DOCK_FACE_DEG);
            if (diff > 180) diff = 360 - diff;
            if (diff < 45)       windRelLabel = "onshore";
            else if (diff > 135) windRelLabel = "offshore";
            else                 windRelLabel = "crosswind";
          }

          const dirName = wdir != null ? toCompass(wdir, false) : "--";

          return {
            startTime: new Date(dayPoints[s].t),
            endTime:   new Date(dayPoints[e].t),
            durMin, peakH, temp, wspd, wdir, dirName, precip,
            windRelLabel, score, windSc, tempSc, precipSc
          };
        }).filter(Boolean);

        // Day label
        const dateObj = new Date(dayStr + "T12:00:00");
        const isToday = dayStr === days[0];
        const dayLabel = isToday ? "Today" : "Tomorrow";
        const dateLabel = dateObj.toLocaleDateString("en-US", { weekday:"short", month:"short", day:"numeric" });

        // Best window score for the day
        const bestScore = usableWindows.length
          ? Math.max(...usableWindows.map(w => w.score))
          : 0;

        dayCards.push({ dayLabel, dateLabel, usableWindows, bestScore, dayStr });
      }

      if (!dayCards.length) {
        el.innerHTML = `<div style="color:rgba(255,255,255,0.4);font-size:0.85rem;">No tide data available</div>`;
        return;
      }

      // Render
      function scoreLabel(s) {
        if (s >= 0.75) return { label:"Great day",  color:"rgba(80,220,120,0.95)",  emoji:"üü¢" };
        if (s >= 0.58) return { label:"Good day",   color:"rgba(160,220,80,0.9)",   emoji:"üü°" };
        if (s >= 0.38) return { label:"Marginal",   color:"rgba(255,190,50,0.85)",  emoji:"üü†" };
        if (s >= 0.20) return { label:"Poor",       color:"rgba(200,100,60,0.85)",  emoji:"üî¥" };
        return            { label:"Stay inside", color:"rgba(150,50,50,0.9)",    emoji:"‚ùå" };
      }

      function fmtTime(d) {
        return d.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit" });
      }

      let html = `<div style="display:grid;grid-template-columns:repeat(${dayCards.length},1fr);gap:12px;">`;

      for (const day of dayCards) {
        const sl = scoreLabel(day.bestScore);
        html += `<div style="background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:10px;padding:14px 12px;">`;
        html += `<div style="font-size:0.78rem;font-weight:800;color:rgba(255,255,255,0.45);margin-bottom:2px;">${day.dayLabel}</div>`;
        html += `<div style="font-size:0.72rem;color:rgba(255,255,255,0.3);margin-bottom:8px;">${day.dateLabel}</div>`;

        if (!day.usableWindows.length) {
          html += `<div style="font-size:1.4rem;margin-bottom:4px;">üî¥</div>`;
          html += `<div style="font-size:0.82rem;font-weight:900;color:rgba(180,80,80,0.8);">Dock dry all day</div>`;
          html += `<div style="font-size:0.72rem;color:rgba(255,255,255,0.3);margin-top:6px;">Low tides fall within usable hours</div>`;
        } else {
          html += `<div style="font-size:1.4rem;margin-bottom:4px;">${sl.emoji}</div>`;
          html += `<div style="font-size:0.88rem;font-weight:900;color:${sl.color};margin-bottom:10px;">${sl.label}</div>`;

          for (const w of day.usableWindows) {
            const durH = Math.floor(w.durMin / 60);
            const durM = w.durMin % 60;
            const durStr = durH > 0 ? `${durH}h ${durM}m` : `${durM}m`;
            const barW = Math.round(w.score * 100);

            html += `<div style="background:rgba(255,255,255,0.04);border-radius:7px;padding:8px 10px;margin-bottom:8px;">`;
            // Window time + duration
            html += `<div style="font-size:0.82rem;font-weight:900;color:rgba(255,255,255,0.85);margin-bottom:2px;">`;
            html += `${fmtTime(w.startTime)} ‚Äì ${fmtTime(w.endTime)}`;
            html += `<span style="font-size:0.7rem;font-weight:700;color:rgba(255,255,255,0.35);margin-left:6px;">${durStr}</span></div>`;
            // Peak height
            html += `<div style="font-size:0.7rem;color:rgba(255,255,255,0.3);margin-bottom:6px;">`;
            html += `Peak ${w.peakH.toFixed(1)} ft`;
            if (DOCK_TIDE_OFFSET_FT !== 0) html += ` <span style="color:rgba(255,200,80,0.6);">(corrected +${DOCK_TIDE_OFFSET_FT} ft)</span>`;
            html += `</div>`;
            // Score bar
            html += `<div style="height:3px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;margin-bottom:8px;">`;
            html += `<div style="height:100%;width:${barW}%;background:${scoreLabel(w.score).color};border-radius:2px;"></div></div>`;
            // Weather details
            html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:2px;font-size:0.7rem;color:rgba(255,255,255,0.5);">`;
            html += `<div>üå°Ô∏è ${w.temp != null ? Math.round(w.temp)+"¬∞F" : "--"}</div>`;
            html += `<div>üíß ${w.precip != null ? w.precip+"%" : "--"} precip</div>`;
            html += `<div data-tip="Wind direction relative to your 315¬∞ NW-facing dock. NW wind is directly onshore ‚Äî kicks up chop against the dock. SE wind is offshore ‚Äî flat calm. NE/SW is crosswind, moderate effect.">`;
            html += `üí® ${w.wspd != null ? Math.round(w.wspd)+" kt" : "--"} ${w.dirName}`;
            html += ` <span style="color:${w.windRelLabel==='offshore'?'rgba(80,220,120,0.8)':w.windRelLabel==='onshore'?'rgba(220,80,80,0.8)':'rgba(255,200,80,0.8)'};">(${w.windRelLabel})</span></div>`;
            if (waterTempRaw != null) {
              html += `<div>üåä ${Math.round(waterTempRaw)}¬∞F water</div>`;
            }
            html += `</div></div>`;
          }
        }
        html += `</div>`;
      }
      html += `</div>`;

      // Footer note
      const offsetNote = DOCK_TIDE_OFFSET_FT !== 0
        ? `Tide heights corrected by ${DOCK_TIDE_OFFSET_FT > 0 ? "+" : ""}${DOCK_TIDE_OFFSET_FT} ft empirical offset. `
        : `No tide correction applied yet ‚Äî update <code>DOCK_TIDE_OFFSET_FT</code> when empirical data available. `;
      html += `<div style="font-size:0.71rem;color:rgba(255,255,255,0.22);margin-top:10px;">`;
      html += `Float threshold ${DOCK_FLOAT_THRESHOLD_FT} ft MLLW. ${offsetNote}`;
      html += `Wind scored relative to ${DOCK_FACE_DEG}¬∞ dock face. Usable hours ${DOCK_USABLE_HOUR_START}:00‚Äì${DOCK_USABLE_HOUR_END}:00.`;
      html += `</div>`;

      el.innerHTML = html;
    }

    function renderTides(tides) {
      const grid = document.getElementById("tideGrid");
      const note = document.getElementById("nextTideNote");
      if (!grid) return;
      grid.innerHTML = "";
      if (note) note.textContent = "";
      if (!Array.isArray(tides) || tides.length === 0) {
        if (note) note.textContent = "No tide data available.";
        return;
      }

      const todayStr = new Date().toISOString().split("T")[0];
      const nowMins  = new Date().getHours() * 60 + new Date().getMinutes();

      // Find next upcoming tide
      let nextIdx = -1;
      for (let i = 0; i < tides.length; i++) {
        const tDate = tides[i].date || todayStr;
        const [th, tm] = (tides[i].time || "00:00").split(":").map(Number);
        if (tDate > todayStr || (tDate === todayStr && (th * 60 + tm) >= nowMins)) {
          nextIdx = i;
          break;
        }
      }

      // Group by date, cap at 4 per day, total 8 max
      const byDate = {};
      let total = 0;
      tides.forEach(t => {
        if (total >= 8) return;
        const d = t.date || todayStr;
        if (!byDate[d]) byDate[d] = [];
        if (byDate[d].length >= 4) return;
        byDate[d].push(t);
        total++;
      });

      const today = new Date().toISOString().split("T")[0];
      const tmrw  = new Date(Date.now() + 86400000).toISOString().split("T")[0];

      let tideIdx = 0;
      Object.keys(byDate).sort().forEach(dateKey => {
        const label = dateKey === today ? "Today" :
                      dateKey === tmrw  ? "Tomorrow" :
                      new Date(dateKey + "T12:00:00").toLocaleDateString("en-US",
                        { weekday:"long", month:"short", day:"numeric" });

        const hdr = document.createElement("div");
        hdr.style.cssText = "font-size:0.8rem;font-weight:900;color:rgba(255,255,255,0.45);" +
                            "letter-spacing:0.8px;text-transform:uppercase;margin:12px 0 6px;";
        hdr.textContent = label;
        grid.appendChild(hdr);

        const row = document.createElement("div");
        row.style.cssText = "display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:4px;";

        const dayTiles = byDate[dateKey];
        dayTiles.forEach(t => {
          const isNext = (tideIdx === nextIdx);
          const tile   = document.createElement("div");
          tile.className = "tide-item";
          if (isNext) tile.style.cssText =
            "border:1px solid rgba(100,200,255,0.45);background:rgba(100,200,255,0.08);border-radius:10px;";
          tile.innerHTML =
            '<div class="tide-type">' + (isNext ? "&#9654; " : "") +
              (t.type === "H" ? "High" : "Low") + '</div>' +
            '<div class="tide-time">' + t.time + '</div>' +
            '<div class="tide-height">' + (t.height ?? "--") + ' ft</div>';
          row.appendChild(tile);
          tideIdx++;
        });

        // Pad empty cells so grid stays 4-column
        for (let i = dayTiles.length; i < 4; i++) {
          row.appendChild(document.createElement("div"));
        }

        grid.appendChild(row);
      });

      if (note) note.textContent = "Salem Harbor (8442645) \u2014 harmonic predictions. \u25b6 = next tide.";
    }

    function buildTideChart(curve, events) {
      const ctx = document.getElementById("tideChart");
      if (!ctx || !curve || !Array.isArray(curve.times) || curve.times.length === 0) return;

      // Thin to every 3rd point (~18-min resolution) to keep chart snappy
      const step = 3;
      const labels  = [];
      const heights = [];
      for (let i = 0; i < curve.times.length; i += step) {
        const raw = curve.times[i]; // "YYYY-MM-DD HH:MM"
        const d   = new Date(raw.replace(" ", "T"));
        labels.push(d.toLocaleTimeString("en-US",
          { weekday: undefined, hour: "numeric", minute: "2-digit" }));
        heights.push(curve.heights[i]);
      }

      // Now-line index (closest point to current time)
      const nowMs = Date.now();
      let nowLineIdx = 0;
      let minDiff   = Infinity;
      for (let i = 0; i < curve.times.length; i += step) {
        const d    = new Date(curve.times[i].replace(" ", "T"));
        const diff = Math.abs(d.getTime() - nowMs);
        if (diff < minDiff) { minDiff = diff; nowLineIdx = Math.floor(i / step); }
      }

      // Annotation points for H/L events
      const pointColors = heights.map(() => "transparent");
      const pointRadius = heights.map(() => 0);

      if (tideChartObj) tideChartObj.destroy();
      tideChartObj = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Tide Height (ft)",
              data: heights,
              borderColor:     "rgba(100,180,255,0.85)",
              backgroundColor: "rgba(100,180,255,0.08)",
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 4,
            },
            // Vertical now-line via a second dataset with a single point
            {
              label: "Now",
              data: labels.map((_, i) => i === nowLineIdx ? heights[i] : null),
              borderColor:  "rgba(255,220,80,0.9)",
              backgroundColor: "rgba(255,220,80,0.9)",
              borderWidth: 0,
              pointRadius: labels.map((_, i) => i === nowLineIdx ? 8 : 0),
              pointStyle:  "triangle",
              fill: false,
              tension: 0,
              showLine: false,
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => ctx.datasetIndex === 0
                  ? " " + ctx.parsed.y.toFixed(1) + " ft"
                  : " Now"
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(255,255,255,0.45)",
                maxTicksLimit: 12,
                maxRotation: 0,
                font: { size: 10, weight: "700" }
              },
              grid: { color: "rgba(255,255,255,0.04)" }
            },
            y: {
              ticks: {
                color: "rgba(255,255,255,0.55)",
                callback: v => v.toFixed(1) + " ft",
                font: { size: 10, weight: "700" }
              },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
    }

    function renderForecast(daily) {
      const el = document.getElementById("forecastList");
      if (!el || !daily || !Array.isArray(daily.dates)) return;
      el.innerHTML = "";
      for (let i = 0; i < Math.min(10, daily.dates.length); i++) {
        const date  = new Date(daily.dates[i] + "T00:00:00");
        const day   = date.toLocaleDateString("en-US", { weekday: "short" });
        const hi    = daily.temperature_max?.[i];
        const lo    = daily.temperature_min?.[i];
        const code  = daily.weather_code?.[i];
        const emoji = weatherEmoji[code] || "&#127777;&#65039;";
        const row   = document.createElement("div");
        row.className = "row";
        row.innerHTML = `<div class="label">${day} ${emoji}</div>
                         <div class="value">${Math.round(hi)}¬∞ / ${Math.round(lo)}¬∞</div>`;
        el.appendChild(row);
      }
    }

    function fillWorryCard(ids, peak, windowHours) {
      // ids: { level, score, peakSpd, dir, exposure, time, note }
      if (!peak) {
        document.getElementById(ids.level).textContent   = "--";
        document.getElementById(ids.score).textContent   = "--";
        document.getElementById(ids.peakSpd).textContent = "-- mph";
        document.getElementById(ids.dir).textContent     = "--";
        document.getElementById(ids.exposure).textContent= "--";
        document.getElementById(ids.time).textContent    = "--";
        return;
      }
      const wl = worryLevel(peak.score);
      document.getElementById(ids.level).innerHTML =
        `<span class="badge ${wl.cls}">${wl.label}</span>`;
      document.getElementById(ids.score).textContent   = peak.score.toFixed(1);
      document.getElementById(ids.peakSpd).textContent = `${Math.round(peak.speed)} mph`;
      document.getElementById(ids.dir).textContent     = toCompass(peak.directionDeg);
      document.getElementById(ids.exposure).textContent= `${(peak.exposureFactor * 100).toFixed(0)}%`;
      document.getElementById(ids.time).textContent    = peak.timeISO ? fmtLocal(peak.timeISO) : "--";
    }

    // Per-card window state
    let _gustWindowHours = 12;
    let _susWindowHours  = 12;

    function renderWindRisk(data) {
      const hourly = data.hourly || {};
      const gustPeak = computePeakWorry(hourly, _gustWindowHours, true);
      const susPeak  = computePeakWorry(hourly, _susWindowHours,  false);

      fillWorryCard(
        { level:"gustLevel", score:"gustScore", peakSpd:"gustPeak",
          dir:"gustDir", exposure:"gustExposure", time:"gustTime", note:"gustNote" },
        gustPeak, _gustWindowHours
      );
      fillWorryCard(
        { level:"susLevel", score:"susScore", peakSpd:"susPeak",
          dir:"susDir", exposure:"susExposure", time:"susTime", note:"susNote" },
        susPeak, _susWindowHours
      );

      const noteEl = document.getElementById("gustNote");
      if (noteEl) noteEl.textContent = `Peak gust wind impact over next ${_gustWindowHours}h. Score = gust √ó exposure¬π¬∑‚Åµ.`;
      const susNoteEl = document.getElementById("susNote");
      if (susNoteEl) susNoteEl.textContent = `Peak sustained impact over next ${_susWindowHours}h. Sustained = dock lines, outdoor use.`;
    }

    // ======================================================
    // Water Temp Calibration Logger (hidden)
    // Records: timestamp, water_temp_f, tide_height_ft, buoy_temp_f, month
    // Stored in localStorage as JSON array under key 'wt_cal_log'
    // ======================================================
    function logWaterTemp() {
      const input  = document.getElementById("wtLogTemp");
      const status = document.getElementById("wtLogStatus");
      const temp   = parseFloat(input.value);
      if (isNaN(temp) || temp < 30 || temp > 95) {
        status.textContent = "Enter a valid temp (30‚Äì95¬∞F)";
        status.style.color = "rgba(255,120,80,0.9)";
        return;
      }

      // Get current tide height from curve
      const data    = window.__lastWeatherData || {};
      const curve   = data.tide_curve || {};
      const ctimes  = curve.times   || [];
      const cheights= curve.heights || [];
      const nowMs   = Date.now();
      let tideH = null;
      let bestDiff = Infinity;
      for (let i = 0; i < ctimes.length; i++) {
        const diff = Math.abs(new Date(ctimes[i]).getTime() - nowMs);
        if (diff < bestDiff) { bestDiff = diff; tideH = cheights[i]; }
      }

      const buoyTemp = (data.buoy_44013 || {}).water_temp_f ?? null;
      const now      = new Date();
      const entry    = {
        ts:         now.toISOString(),
        local_time: now.toLocaleString("en-US"),
        water_temp_f: temp,
        tide_height_ft: tideH !== null ? Math.round(tideH * 100) / 100 : null,
        buoy_temp_f:  buoyTemp,
        offset_f:     buoyTemp !== null ? Math.round((temp - buoyTemp) * 10) / 10 : null,
        month:        now.getMonth() + 1,
      };

      // Save to localStorage
      let log = [];
      try { log = JSON.parse(localStorage.getItem("wt_cal_log") || "[]"); } catch(e) {}
      log.push(entry);
      try { localStorage.setItem("wt_cal_log", JSON.stringify(log)); } catch(e) {}

      input.value = "";
      status.textContent = `‚úì Logged ${temp}¬∞F at tide ${tideH !== null ? tideH.toFixed(1)+"ft" : "unknown"}`;
      status.style.color = "rgba(100,220,120,0.9)";
      renderWaterTempLog();
    }

    function renderWaterTempLog() {
      const el = document.getElementById("wtLogTable");
      if (!el) return;
      let log = [];
      try { log = JSON.parse(localStorage.getItem("wt_cal_log") || "[]"); } catch(e) {}
      if (!log.length) { el.innerHTML = "<em>No readings logged yet.</em>"; return; }

      // Show most recent 20, newest first
      const rows = [...log].reverse().slice(0, 20);
      let html = `<table style="width:100%;border-collapse:collapse;">
        <tr style="color:rgba(255,255,255,0.4);font-size:0.72rem;border-bottom:1px solid rgba(255,255,255,0.1);">
          <th style="text-align:left;padding:4px 8px;">Time</th>
          <th style="text-align:right;padding:4px 8px;">Harbor ¬∞F</th>
          <th style="text-align:right;padding:4px 8px;">Tide ft</th>
          <th style="text-align:right;padding:4px 8px;">Buoy ¬∞F</th>
          <th style="text-align:right;padding:4px 8px;">Offset</th>
        </tr>`;
      for (const e of rows) {
        html += `<tr style="border-bottom:1px solid rgba(255,255,255,0.05);">
          <td style="padding:4px 8px;color:rgba(255,255,255,0.45);">${e.local_time}</td>
          <td style="padding:4px 8px;text-align:right;font-weight:800;">${e.water_temp_f}¬∞</td>
          <td style="padding:4px 8px;text-align:right;">${e.tide_height_ft !== null ? e.tide_height_ft+"ft" : "--"}</td>
          <td style="padding:4px 8px;text-align:right;">${e.buoy_temp_f !== null ? e.buoy_temp_f+"¬∞" : "--"}</td>
          <td style="padding:4px 8px;text-align:right;color:${e.offset_f > 0 ? "rgba(100,220,120,0.8)" : "rgba(255,120,80,0.8)"};">
            ${e.offset_f !== null ? (e.offset_f > 0 ? "+" : "") + e.offset_f+"¬∞" : "--"}
          </td>
        </tr>`;
      }
      html += `</table>`;
      if (log.length > 20) html += `<div style="margin-top:6px;color:rgba(255,255,255,0.3);font-size:0.72rem;">${log.length} total readings stored.</div>`;
      el.innerHTML = html;
    }

    function initWindPills(data) {
      document.querySelectorAll(".wpill").forEach(btn => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.target;
          const hours  = parseInt(btn.dataset.hours, 10);
          // Update active state for this group
          document.querySelectorAll(`.wpill[data-target="${target}"]`)
            .forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          if (target === "gust") _gustWindowHours = hours;
          else                   _susWindowHours  = hours;
          renderWindRisk(window.__lastWeatherData || data);
        });
      });
    }

    // ======================================================
    // Sun (SunCalc)
    // ======================================================
    function renderSun(daily) {
      if (typeof SunCalc === "undefined") return;

      const now  = new Date();
      const pos  = SunCalc.getPosition(now, HOME_LAT, HOME_LON);
      const times= SunCalc.getTimes(now, HOME_LAT, HOME_LON);

      // Altitude and status
      const altDeg = Math.round(pos.altitude * 180 / Math.PI);
      let status, emoji;
      if (altDeg >= 20)       { status = "Above horizon";        emoji = "\u2600\uFE0F"; }
      else if (altDeg >= 5)   { status = "Low in sky";           emoji = "\uD83C\uDF05"; }
      else if (altDeg >= 0)   { status = "Just above horizon";   emoji = "\uD83C\uDF05"; }
      else if (altDeg >= -6)  { status = "Civil twilight";       emoji = "\uD83C\uDF06"; }
      else if (altDeg >= -12) { status = "Nautical twilight";    emoji = "\uD83C\uDF06"; }
      else if (altDeg >= -18) { status = "Astronomical twilight";emoji = "\uD83C\uDF11"; }
      else                    { status = "Below horizon (night)"; emoji = "\uD83C\uDF11"; }

      document.getElementById("sunEmoji").textContent   = emoji;
      document.getElementById("sunStatus").textContent  = status;
      document.getElementById("sunCardTitle").innerHTML = emoji + " Sun \u2014 " + status + ' <span class="collapse-chevron">&#9660;</span>';

      // Azimuth
      const azDeg = Math.round(((pos.azimuth * 180 / Math.PI) + 360) % 360);
      const dirs  = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
      const compass = dirs[Math.round(azDeg / 22.5) % 16];
      document.getElementById("sunAzimuth").textContent  = azDeg + "\u00b0 " + compass;
      document.getElementById("sunAltitude").textContent = altDeg + "\u00b0";

      // Twilight times from SunCalc
      document.getElementById("civilDawn").textContent =
        fmtTime(times.dawn)    || "--";
      document.getElementById("civilDusk").textContent =
        fmtTime(times.dusk)    || "--";

      // Golden hour
      document.getElementById("goldenHourAM").textContent =
        (times.goldenHourEnd ? fmtTime(times.sunrise) + "\u2013" + fmtTime(times.goldenHourEnd) : "--");
      document.getElementById("goldenHourPM").textContent =
        (times.goldenHour    ? fmtTime(times.goldenHour) + "\u2013" + fmtTime(times.sunset)      : "--");

      // Solar noon from SunCalc (more precise than midpoint calc)
      document.getElementById("solarNoonLabel").textContent =
        "Solar noon: " + (fmtTime(times.solarNoon) || "--");

      // Daylight from the daily JSON (already computed in boot)
      // Note: sunNote shows calculation time
      document.getElementById("sunNote").textContent =
        "Position calculated for " +
        now.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit" }) + " local time.";
    }

    // ======================================================
    // Radar ‚Äî RainViewer public API
    // No key required. Smooth interpolated tiles, animated past frames + nowcast.
    // API JSON: https://api.rainviewer.com/public/weather-maps.json
    // Tile URL: {host}{path}/512/{z}/{x}/{y}/{colorScheme}/{smooth}_{snow}.webp
    // ======================================================
    let radarMap       = null;
    let radarInited    = false;
    let radarPlaying   = false;
    let radarTimer     = null;
    let radarFrameIdx  = 0;
    let radarFrames    = [];   // [{ts, path, host, kind}]  kind = "past"|"nowcast"
    let radarLayers    = {};   // path -> L.TileLayer (preloaded)
    let radarActiveLayer = null;
    let radarLayerType = "radar";   // "radar" | "satellite"
    let radarApiData   = null;

    const RADAR_CENTER  = [42.5014, -70.8750];
    const RADAR_ZOOM    = 7;
    const FRAME_DELAY   = 400;
    const COLOR_SCHEME  = 2;   // 0-8; 2 = classic blue‚Üígreen‚Üíyellow‚Üíred
    const SMOOTH        = 1;   // 1 = smoothed/interpolated
    const SNOW_COLORS   = 1;   // 1 = show snow as distinct color
    const TILE_SIZE     = 512;

    function rvTileUrl(host, path, kind) {
      if (kind === "satellite") {
        return `${host}${path}/${TILE_SIZE}/{z}/{x}/{y}/0/0_0.webp`;
      }
      return `${host}${path}/${TILE_SIZE}/{z}/{x}/{y}/${COLOR_SCHEME}/${SMOOTH}_${SNOW_COLORS}.webp`;
    }

    async function fetchRainViewerFrames() {
      try {
        const resp = await fetch("https://api.rainviewer.com/public/weather-maps.json");
        radarApiData = await resp.json();

        radarFrames = [];

        if (radarLayerType === "satellite") {
          // Infrared satellite frames
          const sat = radarApiData.satellite?.infrared || [];
          sat.forEach(f => radarFrames.push({
            ts: new Date(f.time * 1000), path: f.path,
            host: radarApiData.host, kind: "satellite"
          }));
        } else {
          // Radar: past frames + nowcast
          const past = radarApiData.radar?.past || [];
          const now  = radarApiData.radar?.nowcast || [];
          past.forEach(f => radarFrames.push({
            ts: new Date(f.time * 1000), path: f.path,
            host: radarApiData.host, kind: "past"
          }));
          now.forEach(f => radarFrames.push({
            ts: new Date(f.time * 1000), path: f.path,
            host: radarApiData.host, kind: "nowcast"
          }));
        }

        // Update scrubber
        const scrubber = document.getElementById("radarScrubber");
        if (scrubber) {
          scrubber.max   = radarFrames.length - 1;
          scrubber.value = radarFrames.length - 1;
        }
        const fmt = d => d.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit" });
        if (radarFrames.length) {
          const startEl = document.getElementById("radarScrubStart");
          const endEl   = document.getElementById("radarScrubEnd");
          if (startEl) startEl.textContent = fmt(radarFrames[0].ts);
          if (endEl)   endEl.textContent   = fmt(radarFrames[radarFrames.length - 1].ts)
            + (radarLayerType === "radar" ? " (nowcast)" : "");
        }

        // Preload all frame layers (hidden)
        preloadFrames();

        // Show most recent past frame (not nowcast) as default
        const lastPastIdx = radarFrames.map(f => f.kind).lastIndexOf("past");
        showFrame(lastPastIdx >= 0 ? lastPastIdx : radarFrames.length - 1);

      } catch(e) {
        console.error("RainViewer fetch failed:", e);
        document.getElementById("radarTimestamp").textContent = "Error loading radar";
      }
    }

    function preloadFrames() {
      if (!radarMap) return;
      // Remove stale layers
      Object.values(radarLayers).forEach(l => {
        if (radarMap.hasLayer(l)) radarMap.removeLayer(l);
      });
      radarLayers = {};

      radarFrames.forEach(f => {
        const url = rvTileUrl(f.host, f.path, f.kind);
        const layer = L.tileLayer(url, {
          opacity:     0,
          tileSize:    TILE_SIZE,
          zoomOffset:  0,
          maxZoom:     10,
          attribution: '&copy; <a href="https://rainviewer.com">RainViewer</a>',
        });
        layer.addTo(radarMap);
        radarLayers[f.path] = layer;
      });
    }

    function showFrame(idx) {
      if (!radarMap || !radarFrames.length) return;
      idx = Math.max(0, Math.min(idx, radarFrames.length - 1));
      radarFrameIdx = idx;
      const frame = radarFrames[idx];

      // Hide all, show current
      Object.entries(radarLayers).forEach(([path, layer]) => {
        layer.setOpacity(path === frame.path ? 0.7 : 0);
      });
      radarActiveLayer = radarLayers[frame.path];

      // Timestamp with nowcast label
      const timeStr = frame.ts.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit" });
      const label   = frame.kind === "nowcast" ? ` (nowcast)` : "";
      document.getElementById("radarTimestamp").textContent = timeStr + label;
      document.getElementById("radarScrubber").value = idx;

      // Color the scrubber track ‚Äî grey = past, blue = nowcast
      const pct = idx / Math.max(radarFrames.length - 1, 1) * 100;
      const lastPastIdx = radarFrames.map(f => f.kind).lastIndexOf("past");
      const pastPct = lastPastIdx / Math.max(radarFrames.length - 1, 1) * 100;
      const scrubber = document.getElementById("radarScrubber");
      if (scrubber) {
        scrubber.style.background = `linear-gradient(to right,
          rgba(100,180,255,0.8) 0%,
          rgba(100,180,255,0.8) ${pastPct}%,
          rgba(100,255,180,0.6) ${pastPct}%,
          rgba(100,255,180,0.6) ${pct}%,
          rgba(255,255,255,0.15) ${pct}%,
          rgba(255,255,255,0.15) 100%)`;
      }
    }

    function initRadar() {
      if (radarInited) return;
      radarInited = true;

      radarMap = L.map("radarMap", {
        center:  RADAR_CENTER,
        zoom:    RADAR_ZOOM,
        minZoom: 4,
        maxZoom: 10,
        zoomControl: true,
        attributionControl: true,
      });

      // Dark basemap ‚Äî Stadia AlidadeSmoothDark
      L.tileLayer(
        "https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png",
        {
          attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
          maxZoom: 20,
        }
      ).addTo(radarMap);

      // Home marker
      L.circleMarker(RADAR_CENTER, {
        radius: 7, fillColor: "rgba(100,220,255,1)",
        color: "rgba(255,255,255,0.9)", weight: 2, fillOpacity: 1,
        pane: "markerPane",
      }).bindTooltip("Wyman Cove", { permanent: false }).addTo(radarMap);

      setTimeout(() => { if (radarMap) radarMap.invalidateSize(); }, 300);
      fetchRainViewerFrames();

      // Refresh frames every 5 minutes
      setInterval(fetchRainViewerFrames, 5 * 60 * 1000);
    }

    function radarTogglePlay() {
      radarPlaying = !radarPlaying;
      const btn = document.getElementById("radarPlayBtn");
      if (radarPlaying) {
        btn.innerHTML = "&#9646;&#9646; Pause";
        radarAdvance();
      } else {
        btn.innerHTML = "&#9654; Play";
        clearTimeout(radarTimer);
      }
    }

    function radarAdvance() {
      if (!radarPlaying) return;
      let next = radarFrameIdx + 1;
      if (next >= radarFrames.length) {
        next = 0;
        // Brief pause at end before looping
        radarTimer = setTimeout(() => { showFrame(next); radarTimer = setTimeout(radarAdvance, FRAME_DELAY); }, 800);
        return;
      }
      showFrame(next);
      radarTimer = setTimeout(radarAdvance, FRAME_DELAY);
    }

    function radarScrubTo(val) {
      radarPlaying = false;
      document.getElementById("radarPlayBtn").innerHTML = "&#9654; Play";
      clearTimeout(radarTimer);
      showFrame(parseInt(val));
    }

    function setRadarLayer(type) {
      radarLayerType = type;
      ["radar","satellite"].forEach(t => {
        const btn = document.getElementById(
          "btnLayer" + t.charAt(0).toUpperCase() + t.slice(1));
        if (btn) btn.classList.toggle("radar-btn-active", t === type);
      });
      if (radarInited) {
        // Clear preloaded layers and re-fetch for new product
        Object.values(radarLayers).forEach(l => {
          if (radarMap.hasLayer(l)) radarMap.removeLayer(l);
        });
        radarLayers = {};
        radarFrames = [];
        radarApiData && fetchRainViewerFrames();
      }
    }

    // ======================================================
    // Moon (SunCalc)
    // ======================================================
    const HOME_LAT = 42.5014;
    const HOME_LON = -70.8750;

    const MOON_PHASES = [
      { name: "New Moon",        emoji: "\u{1F311}", min: 0,     max: 0.025 },
      { name: "Waxing Crescent", emoji: "\u{1F312}", min: 0.025, max: 0.235 },
      { name: "First Quarter",   emoji: "\u{1F313}", min: 0.235, max: 0.265 },
      { name: "Waxing Gibbous",  emoji: "\u{1F314}", min: 0.265, max: 0.485 },
      { name: "Full Moon",       emoji: "\u{1F315}", min: 0.485, max: 0.515 },
      { name: "Waning Gibbous",  emoji: "\u{1F316}", min: 0.515, max: 0.735 },
      { name: "Last Quarter",    emoji: "\u{1F317}", min: 0.735, max: 0.765 },
      { name: "Waning Crescent", emoji: "\u{1F318}", min: 0.765, max: 0.975 },
      { name: "New Moon",        emoji: "\u{1F311}", min: 0.975, max: 1.0   },
    ];

    function getMoonPhase(fraction) {
      return MOON_PHASES.find(p => fraction >= p.min && fraction < p.max) || MOON_PHASES[0];
    }

    function fmtTime(date) {
      if (!date || isNaN(date.getTime())) return "--";
      return date.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" });
    }

    function azimuthToSky(azRad) {
      const d = ((azRad * 180 / Math.PI) + 360) % 360;
      const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
      const compass = dirs[Math.round(d / 22.5) % 16];
      return { deg: Math.round(d), compass };
    }

    function altitudeDescription(altRad) {
      const deg = Math.round(altRad * 180 / Math.PI);
      let text;
      if (deg < 0)  text = "Below horizon";
      else if (deg < 10) text = "Just above horizon";
      else if (deg < 30) text = "Low in sky";
      else if (deg < 60) text = "Mid sky";
      else               text = "High overhead";
      return { deg, text };
    }

    function daysUntilNextFullMoon() {
      const now = new Date();
      let prev = SunCalc.getMoonIllumination(now).phase;
      for (let d = 1; d <= 30; d++) {
        const candidate = new Date(now.getTime() + d * 86400000);
        const phase = SunCalc.getMoonIllumination(candidate).phase;
        if (prev < 0.5 && phase >= 0.5) return d;
        prev = phase;
      }
      return null;
    }

    function renderMoon() {
      if (typeof SunCalc === "undefined") {
        document.getElementById("moonNote").textContent = "SunCalc library not loaded.";
        return;
      }
      const now   = new Date();
      const illum = SunCalc.getMoonIllumination(now);
      const times = SunCalc.getMoonTimes(now, HOME_LAT, HOME_LON);
      const pos   = SunCalc.getMoonPosition(now, HOME_LAT, HOME_LON);

      const phase = getMoonPhase(illum.phase);
      document.getElementById("moonEmoji").textContent        = phase.emoji;
      document.getElementById("moonPhaseName").textContent    = phase.name;
      document.getElementById("moonIllumination").textContent = Math.round(illum.fraction * 100) + "% illuminated";
      document.getElementById("moonCardTitle").innerHTML      = phase.emoji + " Moon ‚Äî " + phase.name + ' <span class="collapse-chevron">&#9660;</span>';

      document.getElementById("moonrise").textContent =
        times.rise ? fmtTime(times.rise) : (times.alwaysUp ? "Up all night" : "Doesn't rise today");
      document.getElementById("moonset").textContent =
        times.set  ? fmtTime(times.set)  : (times.alwaysDown ? "Below horizon all day" : "--");

      const daysToFull = daysUntilNextFullMoon();
      document.getElementById("nextFullMoon").textContent =
        daysToFull === null ? "--" :
        daysToFull === 0    ? "Tonight" :
        daysToFull === 1    ? "Tomorrow" :
        "In " + daysToFull + " days";

      const az  = azimuthToSky(pos.azimuth);
      const alt = altitudeDescription(pos.altitude);
      document.getElementById("moonAzimuth").textContent  = az.deg + "\u00b0 " + az.compass;
      document.getElementById("moonAltitude").textContent = alt.deg + "\u00b0 \u2014 " + alt.text;
      document.getElementById("moonVisible").textContent  = alt.deg >= 0 ? "Yes" : "No (below horizon)";
      document.getElementById("moonNote").textContent     =
        "Position calculated for " + now.toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit" }) + " local time.";
    }

    // ======================================================
    // NWS Detailed Forecast
    // ======================================================
    function toggleCard(key, el) {
      const card  = el.closest(".card");
      const body  = card.querySelector(".card-body");
      const chev  = el.querySelector(".collapse-chevron");
      if (!body) return;
      const isOpen = body.style.display !== "none";
      body.style.display = isOpen ? "none" : "";
      if (chev) chev.style.transform = isOpen ? "rotate(-90deg)" : "";
      try { localStorage.setItem("card_" + key, isOpen ? "0" : "1"); } catch(e) {}
    }

    function initCollapsibleCards() {
      document.querySelectorAll("[data-collapse-key]").forEach(card => {
        const key     = card.getAttribute("data-collapse-key");
        const openDef = card.getAttribute("data-default-open") !== "false";
        const body    = card.querySelector(".card-body");
        if (!body) return;
        let isOpen = openDef;
        try {
          const stored = localStorage.getItem("card_" + key);
          if (stored !== null) isOpen = stored === "1";
        } catch(e) {}
        body.style.display = isOpen ? "" : "none";
        const chev = card.querySelector(".collapse-chevron");
        if (chev) chev.style.transform = isOpen ? "" : "rotate(-90deg)";
      });
    }

    function toggleAlert(id) {
      const body = document.getElementById(id);
      if (!body) return;
      const idx = id.replace("alertBody_", "");
      const chevron = document.getElementById("alertChevron_" + idx);
      const isOpen = body.style.display !== "none";
      body.style.display = isOpen ? "none" : "block";
      if (chevron) chevron.innerHTML = isOpen ? "&#9660; Show" : "&#9650; Hide";
    }

    function collapseAllAlerts() {
      document.querySelectorAll("[id^='alertBody_']").forEach((body, i) => {
        body.style.display = "none";
        const chev = document.getElementById("alertChevron_" + i);
        if (chev) chev.innerHTML = "&#9660; Show";
      });
    }

    function toggleAlertPanel() {
      const panel = document.getElementById("alertsContainer");
      const chev  = document.getElementById("alertSummaryChev");
      if (!panel) return;
      const isOpen = panel.style.display !== "none";
      panel.style.display = isOpen ? "none" : "";
      if (chev) chev.innerHTML = isOpen ? "&#9660; Show" : "&#9650; Hide";
    }

    let nwsShowAll = false;
    const NWS_PREVIEW = 5;  // periods shown before "show all"

    function renderNWSForecast(periods) {
      const list = document.getElementById("nwsForecastList");
      const btn  = document.getElementById("nwsExpandBtn");
      if (!list || !Array.isArray(periods) || periods.length === 0) {
        if (list) list.innerHTML =
          '<div style="color:rgba(255,255,255,0.4);font-size:0.88rem;padding:8px 0;">No forecast available.</div>';
        return;
      }

      function renderPeriods(all) {
        const toShow = all ? periods : periods.slice(0, NWS_PREVIEW);
        list.innerHTML = "";
        toShow.forEach((p, i) => {
          const isDay   = p.is_daytime !== false;
          const bgAlpha = isDay ? "0.05" : "0.03";
          const row     = document.createElement("div");
          row.style.cssText =
            "display:grid;grid-template-columns:130px 1fr;" +
            "gap:0;border-bottom:1px solid rgba(255,255,255,0.06);" +
            "padding:10px 0;";

          // Left: name + temp + wind
          const left = document.createElement("div");
          left.style.cssText = "padding-right:16px;";
          left.innerHTML =
            '<div style="font-weight:900;font-size:0.9rem;color:rgba(255,255,255,0.9);">' +
              p.name + '</div>' +
            '<div style="font-size:1.4rem;font-weight:900;color:rgba(255,255,255,0.85);margin:2px 0;">' +
              (p.temperature != null ? p.temperature + "\u00b0F" : "--") + '</div>' +
            '<div style="font-size:0.78rem;color:rgba(255,255,255,0.5);font-weight:700;">' +
              (p.wind_speed || "") + " " + (p.wind_direction || "") + '</div>';

          // Right: short forecast bold + detailed text
          const right = document.createElement("div");
          right.innerHTML =
            '<div style="font-weight:900;font-size:0.88rem;color:rgba(255,255,255,0.8);margin-bottom:4px;">' +
              p.short_forecast + '</div>' +
            '<div style="font-size:0.85rem;color:rgba(255,255,255,0.6);line-height:1.5;">' +
              p.detailed + '</div>';

          row.appendChild(left);
          row.appendChild(right);
          list.appendChild(row);
        });

        // Last row ‚Äî remove bottom border
        const rows = list.querySelectorAll("div[style*='border-bottom']");
        if (rows.length > 0) rows[rows.length-1].style.borderBottom = "none";
      }

      renderPeriods(false);

      if (periods.length > NWS_PREVIEW) {
        btn.style.display = "inline-block";
        btn.textContent   = "Show all " + periods.length + " periods \u25be";
      } else {
        btn.style.display = "none";
      }
    }

    function nwsToggleExpand() {
      const btn     = document.getElementById("nwsExpandBtn");
      const periods = window._nwsPeriods || [];
      nwsShowAll    = !nwsShowAll;

      const list = document.getElementById("nwsForecastList");
      const toShow = nwsShowAll ? periods : periods.slice(0, NWS_PREVIEW);
      list.innerHTML = "";
      toShow.forEach(p => {
        const row = document.createElement("div");
        row.style.cssText =
          "display:grid;grid-template-columns:130px 1fr;" +
          "gap:0;border-bottom:1px solid rgba(255,255,255,0.06);padding:10px 0;";
        const left = document.createElement("div");
        left.style.cssText = "padding-right:16px;";
        left.innerHTML =
          '<div style="font-weight:900;font-size:0.9rem;color:rgba(255,255,255,0.9);">' + p.name + '</div>' +
          '<div style="font-size:1.4rem;font-weight:900;color:rgba(255,255,255,0.85);margin:2px 0;">' +
            (p.temperature != null ? p.temperature + "\u00b0F" : "--") + '</div>' +
          '<div style="font-size:0.78rem;color:rgba(255,255,255,0.5);font-weight:700;">' +
            (p.wind_speed || "") + " " + (p.wind_direction || "") + '</div>';
        const right = document.createElement("div");
        right.innerHTML =
          '<div style="font-weight:900;font-size:0.88rem;color:rgba(255,255,255,0.8);margin-bottom:4px;">' +
            p.short_forecast + '</div>' +
          '<div style="font-size:0.85rem;color:rgba(255,255,255,0.6);line-height:1.5;">' +
            p.detailed + '</div>';
        row.appendChild(left);
        row.appendChild(right);
        list.appendChild(row);
      });
      const rows = list.querySelectorAll("div[style*='border-bottom']");
      if (rows.length > 0) rows[rows.length-1].style.borderBottom = "none";

      btn.textContent = nwsShowAll
        ? "Show fewer \u25b4"
        : "Show all " + periods.length + " periods \u25be";
    }

    // ======================================================
    // Boot: load data and populate all views
    // ======================================================
    document.getElementById("pageLoaded").textContent =
      new Date().toLocaleString("en-US", { month: "short", day: "numeric", hour: "numeric", minute: "2-digit" });

    fetch("weather_data.json?t=" + Date.now())
      .then(r => r.json())
      .then(data => {
        window.__lastWeatherData = data;

        // Header
        document.getElementById("location").textContent    = data.location?.name ?? "Wyman Cove";
        document.getElementById("dataUpdated").textContent = fmtLocal(data.generated_at || data.location?.updated);
        renderSources(data.sources, (data.pws || {}).stale);
        renderFrostTracker(data.frost_log);
        renderSunsetQuality(data);
        renderDockDay(data);
        renderSolarSystem();

        // Alerts ‚Äî consolidated summary bar, panel collapsed by default
        const alertsContainer = document.getElementById("alertsContainer");
        const alertSummaryBar = document.getElementById("alertSummaryBar");
        const alertSummaryText = document.getElementById("alertSummaryText");
        alertsContainer.innerHTML = "";
        if (data.alerts && data.alerts.length > 0) {
          if (alertSummaryBar)  { alertSummaryBar.style.display = "flex"; }
          if (alertSummaryText) {
            const n = data.alerts.length;
            alertSummaryText.textContent = `‚ö†Ô∏è ${n} active alert${n > 1 ? "s" : ""}: ${data.alerts.map(a => a.event || "Alert").join(" ¬∑ ")}`;
          }
          alertsContainer.innerHTML = data.alerts.map((a, i) => {
            const id = `alertBody_${i}`;
            return `
            <div class="alert-banner">
              <div class="alert-title" onclick="toggleAlert('${id}')" style="cursor:pointer;display:flex;align-items:center;justify-content:space-between;">
                <span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;min-width:0;">&#9888;&#65039; ${a.event || a.headline?.split(" issued")[0] || "Weather Alert"}</span>
                <span id="alertChevron_${i}" style="font-size:0.8rem;color:rgba(255,255,255,0.5);margin-left:8px;">&#9660; Show</span>
              </div>
              <div id="${id}" class="alert-desc" style="display:none;margin-top:8px;">${a.description || ""}
                ${a.url ? `<div style="margin-top:8px;"><a href="${a.url}" target="_blank" style="color:rgba(100,200,255,0.8);font-size:0.82rem;">Full details &#8599;</a></div>` : ""}
              </div>
            </div>`;
          }).join("");
        }

        // Current conditions
        const cur   = data.current || {};
        const code  = cur.weather_code;
        const emoji = cur.emoji || weatherEmoji[code] || "&#127777;&#65039;";
        const desc  = cur.condition || weatherDesc[code] || "‚Äî";
        document.getElementById("currentTemp").innerHTML =
          `${Math.round(cur.temperature ?? 0)}<span class="temp-unit">¬∞F</span>`;
        document.getElementById("feelsLike").textContent =
          `Feels like ${Math.round(cur.feels_like ?? 0)}¬∞F`;
        document.getElementById("condition").innerHTML = `${emoji} ${desc}`;

        // Hyperlocal
        const pws = data.pws || {};
        const hyp = data.hyperlocal || {};
        document.getElementById("modelTemp").textContent    = (cur.temperature ?? "--") + "¬∞F";
        document.getElementById("pwsTemp").textContent      = (pws.temperature ?? "--") + "¬∞F";
        document.getElementById("tempBias").textContent     = (hyp.bias_temp ?? "--") + "¬∞F";
        document.getElementById("correctedTemp").textContent= (hyp.corrected_temp ?? "--") + "¬∞F";
        document.getElementById("pwsNote").textContent      =
          pws.stale ? "PWS Cached ‚Äî using last good reading." : "PWS Live.";

        // Today summary
        const daily = data.daily || {};
        const hi    = daily.temperature_max?.[0];
        const lo    = daily.temperature_min?.[0];
        document.getElementById("hiLo").textContent =
          (hi != null && lo != null) ? `${Math.round(hi)}¬∞ / ${Math.round(lo)}¬∞` : "-- / --";
        const popMax = daily.precipitation_probability_max?.[0];
        document.getElementById("precipChance").textContent =
          popMax != null ? `${Math.round(popMax)}%` : "--%";

        const der   = data.derived || {};
        const kbos  = data.kbos   || {};

        // Model pressure
        const modelPressEl = document.getElementById("pressureModel");
        if (modelPressEl && cur.pressure != null) {
          modelPressEl.textContent = cur.pressure.toFixed(1) + " hPa";
        }

        // KBOS observed pressure + tendency
        const kbosEl = document.getElementById("pressureKBOS");
        if (kbosEl) {
          if (kbos.pressure_hpa != null) {
            const kbDiff = cur.pressure != null
              ? ` (${(kbos.pressure_hpa - cur.pressure) >= 0 ? "+" : ""}${(kbos.pressure_hpa - cur.pressure).toFixed(1)})`
              : "";
            kbosEl.textContent = kbos.pressure_hpa.toFixed(1) + " hPa" + kbDiff;
            kbosEl.title = "Difference from model";
          } else {
            kbosEl.textContent = "--";
          }
        }

        // KBOS / KBVY observed temps
        const kbvy  = data.kbvy || {};
        const tempObsEl = document.getElementById("tempObsStations");
        if (tempObsEl) {
          const kbosT = kbos.temp_f != null ? kbos.temp_f.toFixed(1) + "¬∞F" : "--";
          const kbvyT = kbvy.temp_f != null ? kbvy.temp_f.toFixed(1) + "¬∞F" : "--";
          tempObsEl.textContent = `${kbosT} / ${kbvyT}`;
        }

        // Pressure trend (3h) ‚Äî prefer KBOS observed tendency if available
        const obsTendency = kbos.tendency_label;
        const trend = obsTendency || der.pressure_trend || "--";
        const tendencyHpa = kbos.tendency_hpa ?? der.pressure_trend_hpa_3h;
        const delta = typeof tendencyHpa === "number"
          ? ` (${tendencyHpa > 0 ? "+" : ""}${tendencyHpa.toFixed(1)} hPa)` : "";
        const trendEl = document.getElementById("pressureTrendHome");
        trendEl.textContent = trend + delta + (obsTendency ? " [obs]" : " [model]");
        trendEl.style.color = trend.includes("fast") && trend.includes("Fall")
          ? "rgba(255,100,100,0.9)"
          : trend === "Falling" ? "rgba(255,180,80,0.9)"
          : trend.includes("Ris") ? "rgba(100,220,120,0.9)"
          : "rgba(255,255,255,0.85)";

        // Fog risk
        const fogEl = document.getElementById("fogRisk");
        if (fogEl) {
          const fogLabel = der.fog_label ?? "--";
          const fogPct   = der.fog_probability;
          fogEl.textContent = fogPct != null ? `${fogLabel} (${fogPct}%)` : fogLabel;
          fogEl.style.color = fogLabel === "Likely"     ? "rgba(255,220,80,0.9)"
                            : fogLabel === "Possible"   ? "rgba(255,200,100,0.85)"
                            : fogLabel === "Low chance" ? "rgba(200,200,200,0.7)"
                            : "rgba(255,255,255,0.85)";
        }

        // Pressure alarm banner
        const alarmBanner = document.getElementById("pressureAlarmBanner");
        if (alarmBanner) {
          const alarm      = der.pressure_alarm;
          const alarmLabel = der.pressure_alarm_label;
          if (alarm && alarmLabel) {
            alarmBanner.textContent  = alarmLabel;
            alarmBanner.className    = `pressure-alarm ${alarm}`;
            alarmBanner.style.display = "";
          } else {
            const tend = der.best_pressure_tend;
            const src  = der.best_pressure_tend_src ?? "model";
            const sign = tend != null && tend > 0 ? "+" : "";
            const tendStr = tend != null ? ` (${sign}${tend.toFixed(1)} hPa, ${src})` : "";
            alarmBanner.textContent  = `Pressure: Normal${tendStr}`;
            alarmBanner.className    = "pressure-alarm";
            alarmBanner.style.display = "";
            alarmBanner.style.background = "rgba(255,255,255,0.04)";
            alarmBanner.style.border = "1px solid rgba(255,255,255,0.08)";
            alarmBanner.style.color  = "rgba(255,255,255,0.45)";
          }
        }

        // Storm mode ‚Äî triggers when 2+ alarm conditions align
        // Integrates into the consolidated alert summary bar
        const stormBanner  = document.getElementById("stormModeBanner");
        const stormDetails = document.getElementById("stormModeDetails");
        const stormFlags = [];
        if (der.pressure_alarm === "falling") stormFlags.push("‚¨áÔ∏è Pressure falling fast");
        if (der.trough_signal === "Approaching") stormFlags.push("üåÄ 850mb trough approaching");
        const gustWorry = (data.wind_risk?.gust?.level ?? "");
        if (["High","Extreme"].includes(gustWorry)) stormFlags.push(`üí® Gust wind impact: ${gustWorry}`);
        const pop0 = (data.daily?.precipitation_probability_max?.[0] ?? 0);
        if (pop0 >= 60 && der.col_precip_type && der.col_precip_type !== "Rain")
          stormFlags.push(`‚ùÑÔ∏è Precip likely ‚Äî column type: ${der.col_precip_type}`);

        if (stormBanner && stormDetails) {
          if (stormFlags.length >= 2) {
            stormBanner.style.display = "";
            stormDetails.innerHTML = stormFlags.map(f => `‚Ä¢ ${f}`).join("<br>");
          } else {
            stormBanner.style.display = "none";
          }
        }

        // If storm flags AND alerts both exist, merge into summary bar
        const hasAlerts = (data.alerts || []).length > 0;
        if (stormFlags.length >= 2 && !hasAlerts) {
          // Storm only ‚Äî show in summary bar
          const bar  = document.getElementById("alertSummaryBar");
          const txt  = document.getElementById("alertSummaryText");
          if (bar && txt) {
            bar.style.display = "flex";
            txt.textContent   = `‚õàÔ∏è Storm conditions: ${stormFlags.map(f => f.replace(/^[^\s]+ /,'')).join(" ¬∑ ")}`;
          }
        }

        // Sea breeze indicator
        const sbRow   = document.getElementById("seaBreezeRow");
        const sbLabel = document.getElementById("seaBreezeLabel");
        const sbText  = der.sea_breeze_label;
        const lsDiff  = der.land_sea_diff_f;
        if (sbRow && sbLabel) {
          sbRow.style.display = "";
          if (sbText && sbText !== "No sea breeze") {
            const diffStr = lsDiff != null ? ` (Œî${lsDiff > 0 ? "+" : ""}${lsDiff}¬∞F)` : "";
            sbLabel.textContent = sbText + diffStr;
            sbLabel.style.color = sbText.includes("likely")     ? "rgba(100,200,255,0.95)"
                                 : sbText.includes("possible")   ? "rgba(150,220,255,0.85)"
                                 : sbText.includes("developing") ? "rgba(180,230,255,0.75)"
                                 : sbText.includes("Land")       ? "rgba(200,200,255,0.75)"
                                 : "rgba(255,255,255,0.75)";
          } else {
            const diffStr = lsDiff != null ? ` (land ${lsDiff > 0 ? "+" : ""}${lsDiff}¬∞F vs water)` : "";
            sbLabel.textContent = `None${diffStr}`;
            sbLabel.style.color = "rgba(255,255,255,0.4)";
          }
        }

        // Wet bulb precip type + 850mb column type ‚Äî only show when precip is likely
        const precipCode = cur.weather_code || 0;
        const precipTypeRow = document.getElementById("precipTypeRow");
        const precipTypeEl  = document.getElementById("precipType");
        const precipType    = cur.precip_type;
        const pop = (data.daily?.precipitation_probability_max?.[0] ?? 0);
        const precipCodes = [51,53,55,61,63,65,71,73,75,77,80,81,82,85,86];
        const showPrecip = pop >= 20 || precipCodes.includes(precipCode);

        if (precipTypeRow && precipTypeEl && precipType && showPrecip) {
          precipTypeRow.style.display = "";
          precipTypeEl.textContent = precipType;
          const wb = cur.wet_bulb;
          precipTypeEl.style.color = wb != null && wb <= 32
            ? "rgba(160,220,255,0.95)"
            : wb != null && wb <= 35
            ? "rgba(255,220,120,0.9)"
            : "rgba(255,255,255,0.85)";
        }

        // 850mb column type
        const col850Row  = document.getElementById("col850Row");
        const col850El   = document.getElementById("col850Type");
        const colType    = der.col_precip_type;
        const colConf    = der.col_precip_conf;
        const t850now    = der.temp_850hpa_now;
        if (col850Row && col850El && colType && showPrecip) {
          col850Row.style.display = "";
          const t850str = t850now != null ? ` (${t850now}¬∞F at 850mb)` : "";
          col850El.textContent = `${colType}${t850str}`;
          col850El.style.color = colType.includes("Heavy snow") ? "rgba(100,180,255,1)"
            : colType.includes("Snow")  ? "rgba(160,220,255,0.95)"
            : colType.includes("Mixed") ? "rgba(255,220,120,0.9)"
            : "rgba(255,255,255,0.85)";
        }

        // Trough signal
        const troughEl   = document.getElementById("troughSignal");
        const troughSig  = der.trough_signal;
        const zTend      = der.height_850hpa_tend_6h;
        if (troughEl && troughSig) {
          const zStr = zTend != null ? ` (${zTend > 0 ? "+" : ""}${zTend}m/6h)` : "";
          troughEl.textContent = troughSig + zStr;
          troughEl.style.color = troughSig === "Approaching"
            ? "rgba(255,180,80,0.9)"
            : troughSig === "Ridging"
            ? "rgba(100,220,120,0.9)"
            : "rgba(255,255,255,0.75)";
        }

        document.getElementById("todayNote").textContent =
          cur.time ? `Current time in model: ${cur.time}` : "";

        const windNowText = (cur.wind_speed != null && cur.wind_direction != null)
          ? `${Math.round(cur.wind_speed)} mph ${toCompass(cur.wind_direction, false)}`
          : "--";
        document.getElementById("windNowHome").textContent = windNowText;

        // Forecast
        renderForecast(daily);

        // 48h charts
        const hourly = data.hourly || {};
        const times  = (hourly.times || []).slice(0, 48);
        buildTempPrecipChart(
          times,
          (hourly.temperature || []).slice(0, 48),
          (hourly.precipitation_probability || []).slice(0, 48),
          (hourly.wet_bulb || []).slice(0, 48)
        );
        buildWindChart(
          times,
          (hourly.wind_speed || []).slice(0, 48),
          (hourly.wind_gusts || []).slice(0, 48)
        );

        // Wind tab
        renderWindRisk(data);
        initWindPills(data);

        const windNowEl      = document.getElementById("windNowWind");
        const windGustsEl    = document.getElementById("windGustsWind");
        const pressureNowEl  = document.getElementById("pressureNowWind");
        const pressureTrendEl= document.getElementById("pressureTrendWind");
        if (windNowEl) windNowEl.textContent =
          (cur.wind_speed != null && cur.wind_direction != null)
            ? `${Math.round(cur.wind_speed)} mph ‚Ä¢ ${toCompass(cur.wind_direction)}`
            : "--";
        if (windGustsEl)     windGustsEl.textContent     = cur.wind_gusts != null ? `${Math.round(cur.wind_gusts)} mph` : "--";
        if (pressureNowEl)   pressureNowEl.textContent   = cur.pressure  != null ? `${cur.pressure.toFixed(1)} hPa` : "--";
        if (pressureTrendEl) pressureTrendEl.textContent = delta ? `${trend} (${delta})` : trend;

        // NWS Forecast
        window._nwsPeriods = data.nws_forecast || [];
        const nwsOfficeEl = document.getElementById('nwsOfficeLabel');
        if (nwsOfficeEl && data.sources && data.sources.nws_forecast) {
          nwsOfficeEl.textContent = data.sources.nws_forecast.office
            ? '\u2014 ' + data.sources.nws_forecast.office + ' office' : '';
        }
        renderNWSForecast(window._nwsPeriods);

        // Almanac tab
        renderTides(data.tides);
        initCollapsibleCards();
        renderWaterTempLog();

        // Touch tooltip support ‚Äî tap to show, tap away to dismiss
        if ('ontouchstart' in window) {
          document.querySelectorAll('[data-tip]').forEach(el => {
            el.addEventListener('touchend', e => {
              e.preventDefault();
              const already = el.classList.contains('tip-active');
              document.querySelectorAll('.tip-active').forEach(t => t.classList.remove('tip-active'));
              if (!already) el.classList.add('tip-active');
            });
          });
          document.addEventListener('touchend', e => {
            if (!e.target.closest('[data-tip]'))
              document.querySelectorAll('.tip-active').forEach(t => t.classList.remove('tip-active'));
          });
        }

        // Buoy 44013
        const buoy = data.buoy_44013 || {};
        const toCompassDir = deg => deg != null ? toCompass(deg, false) : "--";
        const setEl = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };

        setEl("buoyWaterTemp", buoy.water_temp_f != null ? buoy.water_temp_f.toFixed(1) + "¬∞F" : "--");
        setEl("buoyAirTemp",   buoy.air_temp_f   != null ? buoy.air_temp_f.toFixed(1)   + "¬∞F" : "--");
        setEl("buoyPressure",  buoy.pressure_hpa != null ? buoy.pressure_hpa.toFixed(1) + " hPa" : "--");

        const buoyWindEl = document.getElementById("buoyWind");
        if (buoyWindEl) {
          if (buoy.wind_mph != null) {
            const dir = toCompassDir(buoy.wind_dir);
            const gust = buoy.gust_mph != null ? ` (gust ${buoy.gust_mph})` : "";
            buoyWindEl.textContent = `${buoy.wind_mph} mph ${dir}${gust}`;
          } else {
            buoyWindEl.textContent = "--";
          }
        }

        const buoyPtdyEl = document.getElementById("buoyPtdy");
        if (buoyPtdyEl && buoy.pressure_tend_hpa != null) {
          const sign = buoy.pressure_tend_hpa > 0 ? "+" : "";
          buoyPtdyEl.textContent = `${sign}${buoy.pressure_tend_hpa.toFixed(1)} hPa`;
          buoyPtdyEl.style.color = buoy.pressure_tend_hpa <= -3
            ? "rgba(255,100,100,0.9)"
            : buoy.pressure_tend_hpa <= -0.6
            ? "rgba(255,180,80,0.9)"
            : buoy.pressure_tend_hpa >= 0.6
            ? "rgba(100,220,120,0.9)"
            : "rgba(255,255,255,0.75)";
        } else if (buoyPtdyEl) {
          buoyPtdyEl.textContent = "--";
        }

        const waveHtEl = document.getElementById("buoyWaveHt");
        if (waveHtEl) waveHtEl.textContent = buoy.wave_ht_ft != null ? buoy.wave_ht_ft + " ft" : "Calm";
        const wavePdEl = document.getElementById("buoyWavePeriod");
        if (wavePdEl) wavePdEl.textContent = buoy.wave_period_sec != null ? buoy.wave_period_sec + " sec" : "--";
        buildTideChart(data.tide_curve, data.tides);
        const rise = daily.sunrise?.[0]?.split("T")?.[1] ?? "--";
        const set  = daily.sunset?.[0]?.split("T")?.[1] ?? "--";
        document.getElementById("sunrise").textContent = rise;
        document.getElementById("sunset").textContent  = set;

        // Compute daylight duration
        if (rise !== "--" && set !== "--") {
          const [rh, rm] = rise.split(":").map(Number);
          const [sh, sm] = set.split(":").map(Number);
          const mins = (sh * 60 + sm) - (rh * 60 + rm);
          const h = Math.floor(mins / 60), m = mins % 60;
          document.getElementById("daylight").textContent = `${h}h ${m}m daylight`;
        }

        // Sun
        renderSun(daily);

        // Moon
        renderMoon();
      })
      .catch(err => {
        console.error(err);
        document.getElementById("location").textContent = "Error loading weather_data.json";
      });
  </script>

  
</head>

</body>
</html>
